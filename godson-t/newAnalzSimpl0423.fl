let fdebug=fopen "fdebug" "w";
let fdebug1=fopen "fdebug1" "w";
let fdebug2=fopen "fdebug2" "w";
let dist=4;
let cmurphiDir="~/Tools/cmurphi5.4.9/src/mu";
let z3PathName="~/Tools/Isabelle2013-2/contrib/z3-3.2/x86-linux/z3";

let printStrList strList=
        print  "-----------\n"  fseq
	(foreach [str | strList]. print (str^ ";\n" ) ) fseq
	 print  "\n-----------\n"  ;

let down N=N downto 1;


let symId symRel=
   let symRel=tbl_insert symRel 1 1 then   
   tbl_insert symRel 2 2;


lettype varType=Global  {name:: string}    |
    Param   {name:: string} {id ::int};

    
lettype expType=Var varType |  Const int | iteForm formula expType  expType | fun string (expType list) 

andlettype formula = pred (expType list) |
	                eqn {left ::  expType} {right::  expType} |
                  neg {form :: formula} |
                  andList {glist ::   formula list}  |                  
                  orList  {glist::  formula list} |
                  implyForm {ant::  formula} {cons::  formula} |
                  forallForm {N::int} {fnForm::int -> formula} |
                  chaos |
                  miracle;    
  
  
lettype statement= assign varType expType   |  
                   parallel (statement list) |
                   forallStatement {N::int} {fnForm::int -> statement};
                   
lettype rule =  guard formula  statement;     

let subst2Form (v,e)=eqn (Var v) e;

letrec andList2ands (eqn l r)= [(eqn l r)]
/\ andList2ands (andList frms)=flat (map andList2ands frms)
/\ andList2ands (neg frm)=[(neg frm)]
/\ andList2ands (orList  forms)=[orList  forms]
/\ andList2ands (forallForm N fl)=flat (map andList2ands (map fl (down N)))
/\ andList2ands chaos=[]
/\ andList2ands miracle=[miracle];

letrec orList2ors (eqn l r)= [(eqn l r)]
/\ orList2ors (andList frms)=[andList frms]
/\ orList2ors (neg frm)=[(neg frm)]
/\ orList2ors (orList  forms)=flat (map orList2ors forms)
/\ orList2ors (forallForm N fl)=[forallForm N fl]
/\ orList2ors chaos=[chaos]
/\ orList2ors miracle=[ ];

let  isConstExp (Const i)=T
/\   isConstExp _=F;  

let  isIteExp (iteForm cond e1 e2)=T
/\   isIteExp _=F; 

forward_declare  {simpTaut::formula -> formula list};

letrec simpExp (Var v)=Var v
/\ simpExp (Const i)=(Const i)
/\ simpExp (iteForm f e1 e2)=(simpTaut f)=[] =>(simpExp e1) |
                              (simpTaut f)=[miracle]=>(simpExp e2)|
                              iteForm ( f) (simpExp e1) (simpExp e2);

letrec simpTaut (eqn l r)= l=r=>[ ]| 
                           (isConstExp l) AND (isConstExp r)=> 
                           [miracle] |  [ (eqn (simpExp l) (simpExp r))]
/\ simpTaut (andList frms)= (filter (\f. (f!=chaos))  (flat (map simpTaut frms)))
 
/\ simpTaut (neg frm)=
   let mid=(simpTaut frm) then
   mid=[miracle]=> [] | map neg  mid
/\ simpTaut chaos=[]
/\ simpTaut (orList  forms)=[orList  (flat (map simpTaut  forms))]
/\ simpTaut (forallForm N fl)=flat (map simpTaut (map fl (down N)))
/\ simpTaut (forallForm N fl)=[]
/\ simpTaut miracle =[miracle];  

let strengthEn  g exprList =map (\(h,e). (andList (andList2ands (andList [g,h])), e)) exprList;

//letrec iteExp2 (Var v)=[(chaos,Var v)]
///\iteExp2 (Const i)=[(chaos, Const i)]
///\iteExp2 ( iteForm f e1 e2)=
//   let fs=iteForm2 f then
////   let fsT=filter (\(f',f'').f''=chaos) fs then
//   let fsF=filter (\(f',f'').f''=miracle ) fs then
//   let e1s=iteExp2 e1 then
//   let e2s=iteExp2 e1 then
//   let fsTProj=map fst fsT then
//   let fsFProj=map fst fsF then
//   let projT=flat (map (\g. strengthEn g e1s) fsTProj) then
//   let projF=flat (map (\g. strengthEn g e2s) fsFProj) then
//   projT@projF;
   
//letrec iteForm2  (eqn l r)=
//    let ls1=iteExp2 

let strengthEn  g exprList =map (\(h,e). (andList (andList2ands (andList [g,h])), e)) exprList;

forward_declare {subFormulaByAssignList:: (varType # expType) list -> formula -> (formula # formula) list};

letrec subExpByAssignList asgns (Var v) =
  let substV=(snd (hd (filter (\p. fst p=v) asgns)) catch (Var v)) then
  isIteExp substV =>
  val (iteForm cond e1 e2)=substV in
   [(cond, e1),(neg cond,e2)] |
  [(chaos, substV)]
/\ subExpByAssignList asgns (Const i) = [(chaos,(Const i))]
   /\ subExpByAssignList asgns (iteForm f e1  e2) =
  let fs=subFormulaByAssignList asgns f then
  let fsT=filter (\(f',f'').f''=chaos) fs then
  let fsF=filter (\(f',f'').f''=miracle ) fs then 
  let fsTProj=map fst fsT then
  let fsFProj=map fst fsF then
	let e1s=subExpByAssignList asgns e1 then
	let e2s=subExpByAssignList asgns e2 then
	let projT=flat (map (\g. strengthEn g e1s) fsTProj) then
   let projF=flat (map (\g. strengthEn g e2s) fsFProj) then
   projT@projF;
//(	strengthEn f res1 ) @(strengthEn (neg f) res2);




letrec prod  opr [] remainder = []
   /\ prod  opr ((g,f):subGlist') remainder =
   let ands=prod  opr subGlist'  remainder then
   let strengthEn' (g',f') =
        opr=andList=>
        map (\(h,f'). (andList (andList2ands (andList [g',h])),  opr (andList2ands (opr [f,f'])))) remainder|
        map (\(h,f'). (andList (andList2ands (andList [g',h])),  opr (orList2ors (opr [f,f'])))) remainder then
   	  (strengthEn' (g,f))@ands ;
   	  
   	  


letrec transLsDNFs    [(orList cnfs)]=cnfs
   /\ transLsDNFs    ((orList cnfs):others)=
      let cnfs'=transLsDNFs others then
      let andComb  cnf (andList cnf1)= [andList (cnf@cnf1)] then
      let andProd (andList cnf) =flat (map (andComb cnf) cnfs') then
      flat (map andProd cnfs) ;
      
let desOr (orList frms)=frms;      


let getVarName (Global v)=v
/\ getVarName (Param v i)=v;

                                                    
let  inverseVals typeTable vname vval=
   let key=getVarName vname then
   val (Const i)=vval in
   let vals=(tbl_element typeTable key) subtract [i] then
     vals;      
   
letrec elimNot typeTable (eqn left right) = eqn left right 
/\  elimNot typeTable (neg f) =
    val (eqn l r) = f in
    val (Var v) = l in
    let invVals = inverseVals typeTable v r in
    let const2form l c = andList [eqn l (Const c)] in
    orList (map (const2form l) invVals)
/\  elimNot typeTable (andList forms) = andList (map (elimNot typeTable) forms)
/\  elimNot typeTable (orList forms) = orList (map (elimNot typeTable) forms)
/\  elimNot typeTable (implyForm f1 f2) = implyForm (elimNot typeTable f1) (elimNot typeTable f2) 
/\  elimNot typeTable (forallForm N pf) = elimNot typeTable (andList (map pf (down N)));
	
	
letrec form2Dnf typeTable (eqn l r)=	orList [(andList [(eqn l r)])]

/\ form2Dnf typeTable (andList forms)=
   let Lsforms'=map (form2Dnf typeTable) forms then
   orList (transLsDNFs Lsforms')  
   
/\ form2Dnf typeTable (orList forms)=
    let Lsforms'=map (form2Dnf typeTable) forms then
    
    orList (flat (map desOr Lsforms'))
    
/\ form2Dnf typeTable (neg (eqn l r))=  elimNot typeTable (neg (eqn l r))    
/\  form2Dnf typeTable (neg (neg f))=form2Dnf typeTable f
/\  form2Dnf typeTable (neg  (orList forms))=    
   form2Dnf typeTable (andList (map neg forms))
   
/\  form2Dnf typeTable (neg  (andList forms))=    
   form2Dnf typeTable (orList (map neg forms))   ;
   
let normalizeRule   typeTable r=
	val (guard g S)=r in
	val (orList gs)=form2Dnf typeTable g in
	let genRule g'=guard g' S then
	map genRule gs;
	
	   	  
letrec subFormulaByAssignList asgns (eqn le re) =
	let subE1=(subExpByAssignList asgns le ) then
	let subE2=(subExpByAssignList asgns re )  then
	let combine (g,e) =map (\(g2,e2). (andList (andList2ands (andList [g,g2])), (eqn e e2))) subE2 then
	flat (map   combine subE1)
	
/\  subFormulaByAssignList asgns   (neg f) =
	let substF=(subFormulaByAssignList asgns   f ) then
	 let enNeg (g,f') =    (g,(neg f'))   then
    map enNeg  substF
    
 /\  subFormulaByAssignList asgns   (andList [] ) =  [(chaos,andList [])] 
    
/\  subFormulaByAssignList asgns   (andList (f:glist) ) =
	 let remainder= subFormulaByAssignList asgns (andList glist) then
	 let fs=subFormulaByAssignList asgns f then
   prod   andList fs  remainder
   
 
/\  subFormulaByAssignList asgns   (orList [] ) =[(chaos,orList [])] 

/\  subFormulaByAssignList asgns   (orList (f:glist) ) =
	 let remainder= subFormulaByAssignList asgns (orList glist) then
	 let fs=subFormulaByAssignList asgns f then
   prod   orList fs  remainder


/\  subFormulaByAssignList asgns   (implyForm ant0 cons0 ) = 
	let subE1=(subFormulaByAssignList asgns ant0) then
	let subE2=(subFormulaByAssignList asgns cons0)  then
	let combine (g,f) =map (\(g2,f2). (andList (andList2ands (andList [g,g2])), implyForm  f f2)) subE2 then
	
  flat( map combine subE1)
   
   
/\  subFormulaByAssignList asgns   (forallForm N fnForm) = subFormulaByAssignList asgns (andList ((map  fnForm (down N))))
/\  subFormulaByAssignList asgns  chaos=[(chaos,chaos)];
  

letrec parallelStatement2Statements (assign v e)= [assign v e]
/\  parallelStatement2Statements (parallel S)= flat (map parallelStatement2Statements S) 
/\  parallelStatement2Statements (forallStatement N paraSt)=
  let S=  (map  paraSt (down N)) then
  let sts= (map parallelStatement2Statements S) then
    flat sts;


letrec parallelStatement2AssignList (assign v e)= [( v, e) ]
/\  parallelStatement2AssignList (parallel S)= flat (map parallelStatement2AssignList S)
/\  parallelStatement2AssignList (forallStatement N paraSt)=
  let S=  (map  paraSt (down N)) then
  let sts= (map parallelStatement2AssignList S) then
    flat sts;; 


let preCond f S= subFormulaByAssignList  (parallelStatement2AssignList S) f;



//****************************************************************************************************************************************** 
//In our work, each value of a control message is encoded by a unique integer. For readability, a string is 
//allocated to each message to illustrate its meaning.
//For instance, I, T, C, E, TRUE, and FALSE are defined by 0 1 2 3 4 5 6 respectively. 
//Strings  I ,  T ,  C ,  E ,  TRUE ,  FALSE  are related with them respectively. See German.fl
//Part III: another codes for printing variables, values, formulae, and statements into a string
//This code is used to match whether two formulas are symmetric, namely :
//n[1]=C ->!n[2]=C is symmetric n[2]=C --> !n[1]=C
//For a parameterized varaible, we do not print the index 1 into the string, 
//namely "n=C ->!n=C" is generated for the above formula;  after deciding the character string equal, 
//we try to unify the two formulae
//****************************************************************************************************************************************** 
 
let getVarName (Global v)=v
/\ getVarName (Param v i)=v;

let enumTypeOf enumTab name=tbl_element enumTab name;

forward_declare {formula2CharacterStr ::(int, string) htbl -> formula -> string};
let enum2Str  typeval2StrTab i=
    //val (v,val0)=pair in
//  let enumT=enumTypeOf  v  then
//   print (int2str i) fseq
  ( tbl_element typeval2StrTab i) catch (int2str i);
  

let var2CharacterStr  (Global v)=v
/\   var2CharacterStr  (Param v i)=v ;

letrec exp2CharacterStr  typeval2CharacterStrTab  (Var var)=var2CharacterStr var
/\ exp2CharacterStr  typeval2CharacterStrTab  (Const i)=
         mem i (tbl_keys typeval2CharacterStrTab) => enum2Str  typeval2CharacterStrTab i
         | "i" 
/\ exp2CharacterStr  typeval2CharacterStrTab (iteForm f e1 e2)=
	 "iteForm "^ (formula2CharacterStr  typeval2CharacterStrTab f)^
	   (exp2CharacterStr typeval2CharacterStrTab e1)^    
	   (exp2CharacterStr typeval2CharacterStrTab e2)  
         ;


//let assignment2CharacterStr  typeval2CharacterStrTab (Assign v val0)
//    =(var2CharacterStr v)^ = ^(exp2CharacterStr  typeval2CharacterStrTab val0);


letrec formula2CharacterStr  typeval2CharacterStrTab (eqn l r)
   = (exp2CharacterStr  typeval2CharacterStrTab l)^ "=" ^ (exp2CharacterStr  typeval2CharacterStrTab r)
   
/\ formula2CharacterStr  typeval2CharacterStrTab (andList frms)
   =itlist (\e.\str. (formula2CharacterStr  typeval2CharacterStrTab e) ^" & "^str) frms ""  
   
//please note that the formulae will be only allowed when negation is at the    nested level
/\ formula2CharacterStr  typeval2CharacterStrTab (neg frm)=
    "!"^  (formula2CharacterStr  typeval2CharacterStrTab  frm)
    
/\ formula2CharacterStr  typeval2CharacterStrTab (andList [form])=
    (formula2CharacterStr  typeval2CharacterStrTab form)
    
/\ formula2CharacterStr  typeval2CharacterStrTab (orList frms)=
    itlist (\e.\str. (formula2CharacterStr  typeval2CharacterStrTab e) ^" | "^str) frms  ""   

/\  formula2CharacterStr  typeval2CharacterStrTab (implyForm  f1 f2)
   =(formula2CharacterStr  typeval2CharacterStrTab f1)^" -> "^(formula2CharacterStr  typeval2CharacterStrTab f2)
   
/\  formula2CharacterStr  typeval2CharacterStrTab (forallForm N fnForm)
   =(formula2CharacterStr  typeval2CharacterStrTab (andList (map fnForm (down N) )))  
   
/\   formula2CharacterStr  typeval2CharacterStrTab chaos= "chaos"  

/\   formula2CharacterStr  typeval2CharacterStrTab miracle= "false"  ;


letrec statement2CharacterStr  typeval2CharacterStrTab (assign v val0)
    =(var2CharacterStr v)^ "=" ^(exp2CharacterStr  typeval2CharacterStrTab val0)
    

    
/\statement2CharacterStr  typeval2CharacterStrTab (parallel SL)=
     itlist (\s.\str. (statement2CharacterStr  typeval2CharacterStrTab  s) ^" & "^str) SL  "" 
     
/\statement2CharacterStr  typeval2CharacterStrTab (forallStatement N PSL)=
  let  SL=map PSL (down N) then
  statement2CharacterStr  typeval2CharacterStrTab (parallel SL) ;

let rule2CharacterStr  typeval2CharacterStrTab  rule=
  val (guard pre S)= rule in
  ( formula2CharacterStr  typeval2CharacterStrTab  pre)^(" ==>\n" )
   ^(statement2CharacterStr  typeval2CharacterStrTab  S);           
                   
let forAllForm N paraForm=
	  andList (map paraForm (down N));
	  
let existsForm N paraForm=
	  orList (map paraForm (down N));	

let tbl_someUpdate tbl k content=
   // (SOME (tbl_insert tbl k content  )) catch ((tbl_element tbl k)=content => SOME tbl | NONE);
  mem k (tbl_keys tbl) => ((tbl_element tbl k)=content => SOME tbl | NONE)
  |SOME (tbl_insert tbl k content) ;
  
//note that the invariant is always in a special implyForm, e.g., 
//( ( channel2_4[1]=grant_exclusive)  $\longrightarrow$  ($\neg$( cache[2]=exclusive) ) ) ;  
//( ( ( home_exclusive_granted=false)  $\wedge$ ( home_current_command=req_shared)  )  $\longrightarrow$  ($\neg$( channel2_4[1]=invalidate) ) ) ;
//premise is composed of conjunctions, but conclusion is only one formula;

	  
let unifyRight env expFromStatement (Const i)=
  val (SOME env)= env in
  (case expFromStatement where
    (  case (Const i')=i=i'=> SOME env | NONE
     /\case (Var v)=tbl_someUpdate env v (Const i)
     ))
     
/\unifyRight env expFromStatement (Var v)=
   val (SOME env)= env in
  (case expFromStatement where
    (  case (Const i')=tbl_someUpdate env v (Const i')  
     /\case (Var v')=tbl_someUpdate env v' (Var v)
  ));


forward_declare
	{assignPartlyEnableForms:: ((string,(int list)) htbl) ->  ((varType, expType) htbl) opt->statement  ->formula list ->((varType, expType) htbl) opt};

forward_declare	
	{statementPartlyDisableForm ::((string,(int list)) htbl) -> ((varType, expType) htbl) opt -> statement -> formula ->
   ((varType, expType) htbl) opt};   

//There exists an environment that let the assignment always make eq true
//For instance, x:=true always make (x=true) true at any env;
//home_share_list[i]:=home_invalidate_list[i] always make home_share_list[i]=ture by let env<-(home_invalidate_list[1]=true),

let assignPartlyEnableEq  env statement eq=
        val  (eqn vnameExp  vval ) = eq in
        val (Var vname)=vnameExp in
        val (assign  vname' vval') = statement in
        let matchedLeft=(vname'= vname) in
        let matchedRight= unifyRight env vval' vval in
        (NOT matchedLeft  OR  matchedRight=NONE) => NONE |  //env;
                                                    val (SOME env')=matchedRight in
                                                      (tbl_someUpdate env' vname vnameExp);
                                                      
let  inverseVals typeTable vname vval=
   let key=getVarName vname then
   val (Const i)=vval in
   let vals=(tbl_element typeTable key) subtract [i] then
     vals;                                                      

let  selectOneInverseVal typeTable vname vval=
   let key=getVarName vname then
   val (Const i)=vval in
   let vals=(tbl_element typeTable key) subtract [i] then
   hd vals;
   
   

 
letrec assignPartlyEnableForm typeTable env  statement  (eqn vnameExp  vval )=
       assignPartlyEnableEq env  statement (eqn vnameExp  vval )
        
/\     assignPartlyEnableForm  typeTable env  statement  (neg (eqn l r)  )  =
  val (SOME tbl)= env in
  val (assign  vname' vval') = statement  in
  
  let form= (eqn l r)  then
  val (eqn vnameExp  vval ) = form in
	val (Var vname)=vnameExp in
   isConstExp vval'=>
	((assignPartlyEnableForm  typeTable env statement form)	 =NONE =>
         vname=vname'=> tbl_someUpdate tbl vname vval' |NONE
         | NONE) 
   | vname=vname'=>val (Var vnameOfvval') =vval' in tbl_someUpdate tbl vnameOfvval'  (Const (selectOneInverseVal typeTable vname vval)) | NONE 
         
///\     assignPartlyEnableForm env  statement  (neg f  )  =            
//       statementPartlyDisableForm env S f
         
/\     assignPartlyEnableForm typeTable env statement    (andList formList)=NONE;
//       assignPartlyEnableForms env  statement    formList    ;
       
///\     assignPartlyEnableForm env  statement    (orList formList)=
//       assignPartlyEnableForms env  statement    formList         
       
///\     assignPartlyEnableForm env  statement   (implyForm ant0 cons0)=
//       assignPartlyEnableForm env  statement  (orList [neg ant0,cons0])      ;

 //checks whether an assignment makes one of formss always true  	
  
letrec assignPartlyEnableForms  typeTable  env S []= NONE

/\  assignPartlyEnableForms  typeTable  env S (frm:frms)=
    let result=assignPartlyEnableForm   typeTable  env S frm  in
    result=NONE => assignPartlyEnableForms  typeTable  env S frms
    |  result;
    
    
forward_declare
	{statementsPartlyEnableForm :: ((string,(int list)) htbl) -> ((varType, expType) htbl) opt-> statement list -> formula ->((varType, expType) htbl) opt};    
    
letrec statementPartlyEnableForm  typeTable  env (assign  vname' vval') frm=
	   assignPartlyEnableForm   typeTable env (assign  vname' vval') frm
	   
/\   	statementPartlyEnableForm  typeTable  env (parallel statementList) frm=
       statementsPartlyEnableForm  typeTable  env statementList frm
       
/\    statementPartlyEnableForm  typeTable  env (forallStatement  N PSL) frm=
      let  SL=map PSL (down N) then
       statementsPartlyEnableForm  typeTable  env ( SL)  frm      ;
       
       
letrec statementsPartlyEnableForm  typeTable  env [] frm= NONE
/\     statementsPartlyEnableForm   typeTable env (S :  statementList) frm=
     let result=statementPartlyEnableForm   typeTable  env S frm in
     result=NONE  => statementsPartlyEnableForm   typeTable  env statementList frm
    |    result;









letrec statementPartlyDisableForm  typeTable  env S (eqn vnameExp  vval )=
   statementPartlyEnableForm  typeTable  env S (neg (eqn vnameExp  vval ))


/\ statementPartlyDisableForm  typeTable  env S (neg f)=
   statementPartlyEnableForm  typeTable  env S f

/\ statementPartlyDisableForm  typeTable  env S (andList (frm:frmList))=
  // print "PartlyDisable\n" fseq
   
   statementPartlyDisableForm  typeTable  env S frm =NONE =>
   empty frmList =>NONE|
   statementPartlyDisableForm  typeTable  env S (andList frmList) |
   statementPartlyDisableForm  typeTable  env S frm
   
/\ statementPartlyDisableForm  typeTable  env S (forallForm N pf)=
  let fs=map pf (down N) then
    statementPartlyDisableForm  typeTable  env S (andList fs) ;
   
///\ statementPartlyDisableForm env S (orList (frmList))=   
//   statementPartlyDisableForms env S frmList
   
//\ statementPartlyDisableForm env S (implyForm ant0 cons0)=   
//   statementPartlyDisableForms env S (orList [neg ant0,cons0]); 
   
//letrec statementsPartlyDisableForm env [] frm= NONE
///\     statementsPartlyDisableForm  env (S :  statementList) frm=
//     let result=statementPartlyDisableForm  env S frm in
//     result=NONE  => statementsPartlyDisableForm  env statementList frm
//    |    result;   
   

letrec OnGlobals (eqn l r)=
    val (Var v)=l in
    case v where
   (case (Global _)=[(eqn l r)]
    /\case (Param _ _)=[]
    )
    
/\ OnGlobals (andList frms)=flat (map OnGlobals frms)

/\ OnGlobals (neg frm)= (OnGlobals frm)=[]=>[]| [neg frm]

/\ OnGlobals (orList frms)=
	(flat (map OnGlobals frms))=[]=>[]  | [orList frms] 
	
/\ OnGlobals (forallForm N pf)=
  let fs=map pf (down N) then
  flat (map OnGlobals  fs)
	
	;
	

       
let tbl_element' tbl v=
   (tbl_element tbl v) catch (Const (-1));
   
   //(error "not defined variable");    
   
forward_declare {evalFormInEnv::formula -> (varType,expType) htbl ->bool};   
   
letrec evalExpInEnv (Const i) env=Const i
/\     evalExpInEnv (Var v) env=tbl_element' env v
/\     evalExpInEnv (iteForm f e1 e2) env=
       (evalFormInEnv f env)=>evalExpInEnv e1 env | evalExpInEnv e2 env;
       
letrec evalFormInEnv (eqn v vale) env= (evalExpInEnv v env) = (evalExpInEnv vale env) 

/\     evalFormInEnv (neg(eqn v vale)) env= 
                    NOT ((evalExpInEnv v env) = (evalExpInEnv vale env) )
                    
/\     evalFormInEnv  (andList formLs) env=
     itlist (\item.\b.  ( evalFormInEnv item env) AND b) formLs T;      	
	
let conjItem2EnvItem typeTable (eqn ve vale) env=
   let env=
   (val (Var v) =ve in
   tbl_member env v =>  tbl_replace env v vale
   |(tbl_insert env v vale)) then
   env 
   
/\ conjItem2EnvItem  typeTable (neg(eqn ve vale)) env=
   let env=
   val (Var v)=ve in
   let vale'=(Const (selectOneInverseVal typeTable v vale)) then
   
   
   tbl_member env v =>  tbl_replace env v vale'
   //(mem (tbl_element env v) (map Const (inverseVals typeTable v vale)) =>env | tbl_replace env v vale')
   |(tbl_insert env v vale') then
   env ;
   
letrec conjs2Env  typeTable [] env=  env
/\     conjs2Env typeTable (conjItem:conjItems) env=
       let env=conjItem2EnvItem typeTable conjItem env then
       let env=conjs2Env typeTable (conjItems) env then
       env;

       
letrec  form2Env typeTable f env=
       let fs= andList2ands f then
       conjs2Env typeTable fs env;             
       
// we must consider the case where vale is a variable expression or a conditional expression   
let assign2EnvItem (assign v vale) env= 
   let vale'=evalExpInEnv vale env then
   let env=( 
    
   (tbl_member env v =>  tbl_replace env v vale'
   |(tbl_insert env v vale') )) then
   env
   ;
   

       
letrec assigns2Env [] env=env
/\     assigns2Env (assignItem:assignItems) env=
       let env=assign2EnvItem assignItem env then
       let env=assigns2Env (assignItems) env then
       env;      
      
let statement2Env statement env=
    let sts=parallelStatement2Statements statement then
    assigns2Env sts env; 
    
let isUnKnown val0= (val (Const i)=val0 in (i= (- 1))); 

//let tbl_element' tbl v=
//   (tbl_element tbl v) catch (Const (-1));   
    
let checkItemInEnv (eqn v vale) env=
    val (Var v)=v in
    let vale'=(tbl_element' env v) then
   ((vale'=vale ) AND (NOT (isUnKnown vale'))) catch F
   
/\ checkItemInEnv (neg(eqn v vale)) env=
    val (Var v)=v in    
     let vale'=(tbl_element' env v) then
   ((vale'!=vale )  AND (NOT (isUnKnown vale'))) catch F;  
   
let checkItemDisabledInEnv (eqn v vale) env=
    val (Var v)=v in
    
    let valV=(tbl_element' env v) then
   ((valV!=vale ) AND (NOT (isUnKnown valV))) catch F 
   
/\ checkItemDisabledInEnv (neg(eqn v vale)) env=
    val (Var v)=v in
    let valV=(tbl_element' env v) then
   ((valV=vale ) AND (NOT (isUnKnown valV))) catch F;
   
//   ((tbl_element' env v)=vale ) catch F;     
  
let checkConjsInEnv atoms env=
  itlist (\item.\b.  (checkItemInEnv item env) AND b) atoms T;
  
let checkDisableConjsInEnv  atoms env=
  itlist (\item.\b. ( (checkItemDisabledInEnv item env)) OR b) atoms F; 	

let createOneSmtType typeNameTable enumValTab kc =

	let typeName=tbl_element typeNameTable kc in
	typeName="Bool"=>"\n"|
        typeName="Int" =>"\n"|
	let prefix1="(declare-datatypes () (("^typeName in
	let createOneVal vk=" "^(tbl_element enumValTab vk)^" " in 
  let strOfVals=itlist (\a.\b. a^b) (map createOneVal kc) "" in
  let suffix1=")))\n" in
  prefix1^strOfVals^suffix1;
  
 
let createSmtScalarDef typeNameTable enumValTab=
    itlist (\k.\b.(createOneSmtType typeNameTable enumValTab k)^b) (tbl_keys typeNameTable) ""; 

//here k is a string
let createOneSmtFunc aritTable  typeTable typeNameTab k=
   let kt=tbl_element typeTable k in
   (print k) fseq
   let kname=tbl_element typeNameTab kt in
   let prefix1=" (declare-fun "^k^"  " in
   let arit=tbl_element aritTable k in
   let mid= (arit=1) => " (Int) " |" () " in
   let suffix1=kname^")\n" in 
   prefix1^mid^suffix1;
   
   
let createSmtFunc  aritTable  typeTable typeNameTable=
	itlist (\k.\b.(createOneSmtFunc aritTable typeTable typeNameTable k)^b) (tbl_keys typeTable) ""; 
    
    
    

  
 
//****************************************************************************************************************************************** 
//In our work, each value of a control message is encoded by a unique integer. For readability, a string is 
//allocated to each message to illustrate its meaning.
//For instance, I, T, C, E, TRUE, and FALSE are defined by 0 1 2 3 4 5 6 respectively. 
//Strings  I ,  T ,  C ,  E ,  TRUE ,  FALSE  are related with them respectively. See German.fl
//Part I: codes for printing variables, values, formulae, and statements into a string
//****************************************************************************************************************************************** 

forward_declare {formula2str::(int, string) htbl -> formula -> string}; 

let var2Str  (Global v)=v
/\   var2Str  (Param v i)=v^ "[" ^(int2str i)^ "]" ;

letrec exp2str  typeval2StrTab  (Var var)=var2Str var
/\ exp2str  typeval2StrTab  (Const i)=
         enum2Str  typeval2StrTab i
/\ exp2str typeval2CharacterStrTab (iteForm f e1 e2)=
	  "("^(formula2CharacterStr  typeval2CharacterStrTab f)^ " ? "^
	   (exp2str typeval2CharacterStrTab e1)^  " : "^   
	   (exp2str typeval2CharacterStrTab e2)^")"           
         ;


//let assignment2Str  typeval2StrTab (Assign v val0)
//    =(var2Str v)^ = ^(exp2str  typeval2StrTab val0);


letrec formula2str  typeval2StrTab (eqn l r)
   = "( "^(exp2str  typeval2StrTab l)^ "=" ^ (exp2str  typeval2StrTab r)^") "

///\ formula2str  typeval2StrTab (andList [frm])=formula2str  typeval2StrTab \\frm ^ (formula2str  typeval2StrTab frm)
   
/\ formula2str  typeval2StrTab (andList (frms))=
   frms=[]=>"true"|
   let str=(itlist (\e.\str. (formula2str  typeval2StrTab e) ^" & "^str) frms "" ) in
   //let strs=explode str in
   //let str=implode (
   "( "^(str_substr str 1 (strlen str -2))^") "


/\ formula2str  typeval2StrTab (neg frm)=
     " (!" ^(formula2str  typeval2StrTab  frm)^") "
    
///\ formula2str  typeval2StrTab (andList [form])=
//    (formula2str  typeval2StrTab form)
    
/\ formula2str  typeval2StrTab (orList frms)=
   let str= itlist (\e.\str. (formula2str  typeval2StrTab e) ^" | "^str) frms  ""  in
   "( "^ (str_substr str 1 (strlen str -2))^") "  

/\  formula2str  typeval2StrTab (implyForm  f1 f2)
   ="( "^(formula2str  typeval2StrTab f1)^" -> "^(formula2str  typeval2StrTab f2)^") "
   
/\ formula2str  typeval2StrTab (forallForm  N pf)
   =formula2str  typeval2StrTab (andList (map pf (down N)))
   
/\formula2str  typeval2StrTab chaos="true"

/\formula2str  typeval2StrTab miracle="false";


letrec statement2Str  typeval2StrTab (assign v val0)
    =(var2Str v)^ "=" ^(exp2str  typeval2StrTab val0)
    

    
/\statement2Str  typeval2StrTab (parallel SL)=
     itlist (\s.\str. (statement2Str  typeval2StrTab  s) ^" & "^str) SL  "" 
     
/\statement2Str  typeval2StrTab (forallStatement N PSL)=
  let SL=map PSL (down N) then
   statement2Str  typeval2StrTab (parallel SL);

let rule2Str  typeval2StrTab  rule=
  val (guard pre S)= rule in
  ( formula2str  typeval2StrTab  pre)^(" ==>\n" )
   ^(statement2Str  typeval2StrTab  S); 
   


//****************************************************************************************************************************************** 
//In our work, each value of a control message is encoded by a unique integer. For readability, a string is 
//allocated to each message to illustrate its meaning.
//For instance, I, T, C, E, TRUE, and FALSE are defined by 0 1 2 3 4 5 6 respectively. 
//Strings  I ,  T ,  C ,  E ,  TRUE ,  FALSE  are related with them respectively. See German.fl
//Part I: codes for printing variables, values, formulae, and statements into a string

//code for generating Isabelle definition for vars, exps, formulas, statements.
//****************************************************************************************************************************************** 


//let enumTypeOf enumTab name=tbl_element enumTab name;


//let enum2Str  typeval2StrTab i=
 //val (v,val0)=pair in
//  let enumT=enumTypeOf  v  then
//   print (int2str i) fseq
//  ( tbl_element typeval2StrTab i) catch (int2str i);

//definition paraCritRule::"nat \<Rightarrow> rule" where [simp]: 
 // " paraCritRule i \<equiv>  
 //      ( let g1= eqn (IVar (Para  ''n'' i)) (Const T) in 
 //        let g2=  eqn (IVar (Global  ''x'' )) (Const TRUE) in
 //        let a=   ((Para  ''n'' i), (Const C)) in
//         let Sent2= assign  ((Global  ''x'' ), (Const FALSE)) in
//             guard (andForm g1 g2) (parallel a  Sent2))"
//kk;

forward_declare {formula2Isabellestr::(int, string) htbl -> formula -> string}; 	
let var2IsabelleStr  (Global v)="( Global ''"^v^"'')"
/\   var2IsabelleStr  (Param v i)="( Para ''"^v^ "'' " ^"iInv"^(int2str i)^ ")" ;

letrec exp2IsabelleStr  typeval2StrTab  (Var var)="( IVar "^(var2IsabelleStr  var)^" )"
/\ exp2IsabelleStr  typeval2StrTab  (Const i)=
let str=(enum2Str  typeval2StrTab i) then
"( Const "^str^" )"
/\ exp2IsabelleStr typeval2CharacterStrTab (iteForm f e1 e2)=
	  "(if "^(formula2Isabellestr  typeval2CharacterStrTab f)^ " then "^
	   (exp2IsabelleStr typeval2CharacterStrTab e1)^  " else "^   
	   (exp2IsabelleStr typeval2CharacterStrTab e2)^")"  ;
         





letrec formula2Isabellestr  typeval2StrTab (eqn l r)
   =  
    "(eqn  "^(exp2IsabelleStr typeval2StrTab  l)^ "  " ^ (exp2IsabelleStr  typeval2StrTab r)^") "

 
   
/\ formula2Isabellestr  typeval2StrTab (andList (frms))=
   length frms=1=>val [frm]=frms in
     formula2Isabellestr  typeval2StrTab frm |
   let str1=itlist (\e.\str.  "( andForm "^str ^"   "^(formula2Isabellestr  typeval2StrTab e)^" ) ") (tl frms) 
      ( formula2Isabellestr  typeval2StrTab  (hd frms))  in str1

/\ formula2Isabellestr  typeval2StrTab (neg frm)=
     " (neg "^(formula2Isabellestr  typeval2StrTab  frm)^") "
    
 
    
/\ formula2Isabellestr  typeval2StrTab (orList frms)=
   length frms=1=>val [frm]=frms in formula2Isabellestr  typeval2StrTab frm |
   let str1=itlist (\e.\str. "( orForm "^str ^"   "^(formula2Isabellestr  typeval2StrTab e)^" ) ") (tl frms) 
      ( formula2Isabellestr  typeval2StrTab  (hd frms)) in str1


/\  formula2Isabellestr  typeval2StrTab (implyForm  f1 f2)
   ="(implyForm "^(formula2Isabellestr  typeval2StrTab f1)^"  "^(formula2Isabellestr  typeval2StrTab f2)^") "
   
/\    formula2Isabellestr  typeval2StrTab (forallForm  N pf)
   ="let pf=%i. "^(formula2Isabellestr  typeval2StrTab (pf 1))^" in\n"^
   "let natList=down N in\n"^
   "(forallForm "^"natList  pf) "
   
/\    formula2Isabellestr  typeval2StrTab chaos="true"

/\    formula2Isabellestr  typeval2StrTab false="false"    ;    


letrec statement2IsabelleStr  typeval2StrTab (assign v val0)
    ="  ("^(var2IsabelleStr v)^ ",  " ^(exp2IsabelleStr  typeval2StrTab val0)^" )"
    

    
/\statement2IsabelleStr  typeval2StrTab (parallel SL)=
     length SL=1=>
	   val [S]=SL in "(assign "^(statement2IsabelleStr  typeval2StrTab S)^" )" |
	   let len=length SL in
	   let ls=1 upto len in
	   let strLs=map 
	   (\i. i =len => "let S_"^(int2str i)^"="^"(assign "^(statement2IsabelleStr  typeval2StrTab (el i SL))^" ) in\n"
	         | "let S_"^(int2str i)^"="^(statement2IsabelleStr  typeval2StrTab (el i SL))^" in\n" ) ls in
	   let SiS=map (\i. "S_"^(int2str i)) ls in
	   let SiS'=firstn  (len - 1) SiS in
     let str1=itlist (\e.\str.   e ^str) strLs "" in
     let str2=itlist (\e.\str. "( parallel "^e^" "^str^")") SiS' (el len SiS)
       in
 	"("^str1^str2^" )"
 	
/\ statement2IsabelleStr  typeval2StrTab (forallStatement N PSL)=	
  "let ps=%i. "^(statement2IsabelleStr  typeval2StrTab (PSL 1))^" in\n"^
   "let natList=down N in\n"^
   "(forallSent "^"natList  ps) ";
 
let rule2IsabelleStr  typeval2StrTab  rule=
  val (guard pre S)= rule in
  (val (assign v val0)= S in 
  (let strOfS= "let S=(\n assign "^(statement2IsabelleStr  typeval2StrTab  S)^ (") in \n" ) in 
  "let g="^( formula2Isabellestr  typeval2StrTab  pre)^(" in \n" )^strOfS^ 
  "guard g S") ) catch 
  
  (let strOfS= "let S=(\n"^(statement2IsabelleStr  typeval2StrTab  S)^ (") in \n" ) in 
  "let g="^( formula2Isabellestr  typeval2StrTab  pre)^(" in \n" )^strOfS^ 
  "guard g S"); 
  
  
forward_declare {formula2ParamIsabellestr::((int,string) htbl) -> formula -> string}; 
	
//here  paraTab is a mapping from the concrete values to a its order in the occurence of the value
//for instance for the formula:( channel2_4[2]=grant_shared)  ->  (!( cache[1]=exclusive) )
//2->1; 1->2

let var2ParamIsabelleStr    (Global v)="( Global ''"^v^"'')"
/\   var2ParamIsabelleStr    (Param v i)="( Para ''"^v^ "'' iInv" ^(int2str (i))^ ")" ;

//forward_declare {formula2Isabellestr::(int, string) htbl -> formula -> string}; 

letrec exp2ParamIsabelleStr  typeval2StrTab     (Var var)="( IVar "^(var2ParamIsabelleStr    var)^" )"
/\ exp2ParamIsabelleStr  typeval2StrTab     (Const i)="( Const "^(enum2Str  typeval2StrTab i)^" )"
  //( mem i (tbl_keys typeval2StrTab))=> "( Const "^(enum2Str  typeval2StrTab i)^" )" |"i"
  
/\ exp2ParamIsabelleStr typeval2CharacterStrTab (iteForm f e1 e2)=
	  "(iteForm "^(formula2ParamIsabellestr typeval2CharacterStrTab f)^ "  "^
	   (exp2ParamIsabelleStr typeval2CharacterStrTab e1)^  "  "^   
	   (exp2ParamIsabelleStr typeval2CharacterStrTab e2)^")"  ;;
         





letrec formula2ParamIsabellestr  typeval2StrTab    (eqn l r)
   =  
    "( eqn "^(exp2ParamIsabelleStr  typeval2StrTab  l)^ "  " ^ (exp2ParamIsabelleStr  typeval2StrTab  r)^") "

 
   
/\ formula2ParamIsabellestr  typeval2StrTab    (andList (frms))=
   length frms=1=>val [frm]=frms in
     formula2ParamIsabellestr  typeval2StrTab    frm |
   let str1=itlist (\e.\str.  "( andForm "^str ^"   "^(formula2ParamIsabellestr  typeval2StrTab    e)^" ) ") (tl frms) 
      ( formula2ParamIsabellestr  typeval2StrTab     (hd frms))  in str1

/\ formula2ParamIsabellestr  typeval2StrTab    (neg frm)=
     " (neg "^(formula2ParamIsabellestr  typeval2StrTab     frm)^") "
    
 
    
/\ formula2ParamIsabellestr  typeval2StrTab    (orList frms)=
   length frms=1=>val [frm]=frms in formula2ParamIsabellestr  typeval2StrTab    frm |
   let str1=itlist (\e.\str. "( orForm "^str ^"   "^(formula2ParamIsabellestr  typeval2StrTab    e)^" ) ") (tl frms) 
      ( formula2ParamIsabellestr  typeval2StrTab     (hd frms)) in str1


/\  formula2ParamIsabellestr  typeval2StrTab    (implyForm  f1 f2)
   ="(implyForm "^(formula2ParamIsabellestr  typeval2StrTab    f1)^"  "^(formula2ParamIsabellestr  typeval2StrTab    f2)^") "
   
/\   formula2ParamIsabellestr  typeval2StrTab    (forallForm  N  pf) =
   formula2ParamIsabellestr  typeval2StrTab  (andList (map pf (down N)))
   
/\   formula2ParamIsabellestr  typeval2StrTab  chaos= "chaos "   

;


letrec statement2ParamIsabelleStr  typeval2StrTab     (assign v val0)
    ="  ("^(var2ParamIsabelleStr  v)^ ",  " ^(exp2ParamIsabelleStr  typeval2StrTab    val0)^" )"
    

    
/\statement2ParamIsabelleStr  typeval2StrTab    (parallel SL)=
     length SL=1=>
	   val [S]=SL in "(assign "^(statement2ParamIsabelleStr  typeval2StrTab    S)^" )" |
	   let len=length SL in
	   let ls=1 upto len in
	   let strLs=map 
	   (\i. i =len => "let S_"^(int2str i)^"="^"(assign "^(statement2ParamIsabelleStr  typeval2StrTab    (el i SL))^" ) in\n"
	         | "let S_"^(int2str i)^"="^(statement2ParamIsabelleStr  typeval2StrTab    (el i SL))^" in\n" ) ls in
	   let SiS=map (\i. "S_"^(int2str i)) ls in
	   let SiS'=firstn  (len - 1) SiS in
     let str1=itlist (\e.\str.   e ^str) strLs "" in
     let str2=itlist (\e.\str. "( parallel "^e^" "^str^")") SiS' (el len SiS)
       in
 	"("^str1^str2^" )"
 	
/\ statement2ParamIsabelleStr  typeval2StrTab    (forallStatement N PSL)=	
   statement2ParamIsabelleStr  typeval2StrTab    (parallel (map PSL (down N)));
 
let rule2ParamIsabelleStr  typeval2StrTab     rule=
  val (guard pre S)= rule in
  (val (assign v val0)= S in 
  (let strOfS= "let S=(\n assign "^(statement2ParamIsabelleStr  typeval2StrTab     S)^ (") in \n" ) in 
  "let g="^( formula2ParamIsabellestr  typeval2StrTab    pre)^(" in \n" )^strOfS^ 
  "guard g S") ) catch 
  
  (let strOfS= "let S=(\n"^(statement2ParamIsabelleStr  typeval2StrTab    S)^ (") in \n" ) in 
  "let g="^( formula2ParamIsabellestr  typeval2StrTab     pre)^(" in \n" )^strOfS^ 
  "guard g S"); 
    
   
//****************************************************************************************************************************************** 
//Part II: codes for computing variables of a variable, expression, formula, and statement
//****************************************************************************************************************************************** 
    
   
let varsOfVar  x  = [x]  ;

letrec  varOfExp  (Var v) =   varsOfVar v   
/\   varOfExp   (Const j) =  [] 
/\    varOfExp   (iteForm f e1 e2) = (varOfExp e1) union (varOfExp e2) ;


letrec   varOfForm   (eqn e1 e2) = ( (varOfExp   e1 )  union   (varOfExp  e2))   
/\       varOfForm   ( andList formList) = setify ( flat (map varOfForm  formList ) )   
/\       varOfForm   (neg f1 ) = (  (varOfForm   f1 ))  
/\       varOfForm   (orList formList) = setify ( flat (map varOfForm  formList ))   
/\       varOfForm   (implyForm f1 f2) = (  (varOfForm  f1 )   union  (varOfForm f2 ))
/\       varOfForm   (forallForm N pf) =   varOfForm  (andList (map pf (down N) )  ) 
/\   varOfForm  (chaos)=[];

letrec  varOfStatement  (assign v val0)=( varsOfVar  v) 
//union (varOfExp  val0)  
/\      varOfStatement  ( parallel sentList)= flat  (map varOfStatement  sentList) ;   
   
let paraIndexOfVar  (Param vn i)=[i]
/\  paraIndexOfVar (Global vn)=[];

forward_declare {paraIndexsOfForm::int -> formula -> int list};

letrec  paraIndexsOfExp dist (Var v) =   paraIndexOfVar v   
/\   paraIndexsOfExp   dist  (Const j)=  j<dist =>[j]| [] 
/\  paraIndexsOfExp   dist (iteForm cond e1 e2)= (paraIndexsOfExp dist e1) union (paraIndexsOfExp dist e2) union (paraIndexsOfForm  dist cond) ;


letrec   paraIndexsOfForm  dist (eqn e1 e2) = ( (paraIndexsOfExp dist  e1 )  union   (paraIndexsOfExp dist e2))   
/\       paraIndexsOfForm  dist ( andList formList) = setify ( flat (map (paraIndexsOfForm  dist) formList ) )   
/\       paraIndexsOfForm  dist (neg f1 ) = (  (paraIndexsOfForm  dist f1 ))  
/\       paraIndexsOfForm  dist (orList formList) = setify ( flat (map (paraIndexsOfForm dist)  formList ))   
/\       paraIndexsOfForm  dist (implyForm f1 f2) = (  (paraIndexsOfForm dist f1 )   union  (paraIndexsOfForm dist f2 )) 
/\       paraIndexsOfForm  dist (forallForm N pf)= paraIndexsOfForm  dist (andList (map pf (down N) )  ) 
/\       paraIndexsOfForm  dist (chaos)= []
/\       paraIndexsOfForm  dist (miracle)= [];

//let paraIndexsOfForm f =setify (flat (map paraIndexOfVar (varOfForm f)));
   
//****************************************************************************************************************************************** 
//The following codes call murphi to decide whether an invariant hold for a bound model
//invariants are guessed by murphi oracle
//The way to create new invariants depends on the induction principle
//heuristics are invHoldForRule1, invHoldForRule3, invHoldForRule4.
//******************************************************************************************************************************************    


let premisesOfRule ruelInst=
    val (guard pre s)= ruelInst in
    andList2ands pre;

letrec rec_copy fp1 fp2 =
    let s = fgets fp1
    then
    (feof fp1) => ()
    |  fputs fp2 s
    seq
    fflush fp2
    seq
    rec_copy fp1 fp2; 


letrec checkSucFlag fp1=
    (feof fp1)=>
    (//print "error found\n" fseq 
     F)
    |let s = fgets fp1 then
  // % print s fseq
    
    (str_is_prefix  "	No error found."  s=> 
    (//print "No error found\n" fseq 
     T)|checkSucFlag fp1);
        
let searchSuc fileName=     
   let fin = fopen (fileName) "r" 
   then let result= checkSucFlag fin then
   (fclose fin) fseq result;



let form2MurphiInv enumTab inv=
    "ruleset i:client do\n"^ "   invariant \"coherent\" \n"^ (formula2str enumTab inv)^"\n"^"end;\n";

let setTautISImpliedisInVTriple taut isImplied isInv No=(taut, isImplied, isInv,No);


 
let dualNeg (neg f)=f
 /\  dualNeg f=neg f;   
 
   
let  cmpForm typeval2StrTab form1 form2=
 strcmp (formula2CharacterStr typeval2StrTab form1) (formula2CharacterStr typeval2StrTab form2);
	  
let normalize typeval2StrTab formulaList=qsort  (cmpForm typeval2StrTab) formulaList;
let getReal (SOME v)=v;   
 

    
let unifyVar symIndice env v1 ( Global vname)=
   let env=getReal env in
    (case v1 where
    (  case (Global vname')= vname=vname'=>SOME env | NONE
     /\case (Param vname' i)=NONE
     ))
     
/\ unifyVar symIndice env v1 ( Param vname i)=
   let env=getReal env in
   mem i symIndice=>
   
    (case v1 where
    (  case (Global vname')=  NONE
    
     /\case (Param vname' j)
     =(vname=vname')  =>
         mem j (tbl_keys env) =>
          ( tbl_element env j=i=>SOME env |NONE) 
        | mem i (tbl_keys env) =>
            ( tbl_element env i=j=>SOME env |NONE)
            
        |SOME (i=j=>env|(let env=(tbl_insert env i j) then  (tbl_insert env  j i)) ) 
      | NONE
     )) 
   |(case v1 where
    (  case (Global vname')= vname=vname'=>SOME env | NONE
     /\case (Param vname' j)=(i=j)=>SOME env | NONE
     ))  ;    
     
let unifyLeft symIndice env exp  (Const i)=
  (case exp  where
    (  case (Const i')= (i=i'=>env | NONE)
     /\case (Var v)=NONE
     ))
     
/\unifyLeft symIndice env exp  (Var v)=
  print ((var2Str v)^"............\n") fseq
  (case exp  where
    (  case (Const i')=NONE
     /\case (Var v')=unifyVar symIndice env v' v
   )); 
    
forward_declare {matchForm:: int list  ->
 (int, string) htbl -> (((int, int) htbl) opt) -> 
  (formula # formula)  -> (((int, int) htbl) opt) };

 letrec unifyLeft   symIndice  typeval2StrTab  env exp  (Const i)=
  (case exp  where
    (  case (Const i')= (i=i'=>env | NONE)
     /\case (Var v)=NONE
     ))
     
/\unifyLeft  symIndice   typeval2StrTab  env exp  (Var v)=
 // print ((var2Str v)^"............\n") fseq
  (case exp  where
    (  case (Const i')=NONE
     /\case (Var v')=unifyVar  symIndice  env v' v
   ))
/\unifyLeft   symIndice  typeval2StrTab env exp  (iteForm f e1 e2)=
 // print ((var2Str v)^"............\n") fseq
  (case exp  where
    (  case (Const i')=NONE
     /\case (Var v')=NONE
     /\case (iteForm f' e1' e2')=
      let env= matchForm   symIndice  typeval2StrTab  env (f, f') then
      let env=unifyLeft  symIndice  typeval2StrTab  env e1 e1' then
      unifyLeft  symIndice  typeval2StrTab  env e2 e2'
   ))   ;
   
//forward_declare
//	{assignPartlyEnableForms::  statement -> int list  -> formula list ->((varType #expType) list) opt};
 
forward_declare {matchFormLs::  int list ->
 (int, string) htbl -> (((int, int) htbl) opt) -> 
  (formula # formula) list -> (((int, int) htbl) opt) };

letrec matchForm    symIndice  typeval2StrTab env ((eqn l r), (eqn l' r')) =
    (r=r') =>	(unifyLeft   symIndice    typeval2StrTab env l l')  | NONE
   	
/\    matchForm   symIndice  typeval2StrTab env ((neg f1), (neg f2)) = 
   matchForm   symIndice  typeval2StrTab env (f1,f2)

/\matchForm   symIndice typeval2StrTab env ((eqn l r), (neg f2)) =
   	//matchForm typeval2StrTab env ((eqn l r),  f2)
   	NONE
   	
/\matchForm  symIndice  typeval2StrTab env ((neg f1), (eqn l' r')) =
   	//matchForm typeval2StrTab env (f1,(eqn l' r')) 
   	NONE     	   	
     
/\  	matchForm  symIndice  typeval2StrTab env ( (andList formList),  (andList formList'))=
      (length formList = length formList') =>  
          	matchFormLs  symIndice  typeval2StrTab env  (zip formList formList')  
         | NONE



/\    matchForm  symIndice  typeval2StrTab env ( (orList formList),  (orList formList'))=
       (length formList = length formList') =>  
          	matchFormLs  symIndice  typeval2StrTab env  (zip formList formList')  
         | NONE
    		
/\  	matchForm  symIndice typeval2StrTab  env ((implyForm ant1 cons1), (implyForm ant2 cons2)) =
     matchForm  symIndice  typeval2StrTab env 
     (orList (normalize typeval2StrTab [dualNeg ant1, cons1]), orList (normalize typeval2StrTab [dualNeg ant2, cons2]))

/\  	matchForm  symIndice  typeval2StrTab  env (f1, f2)=NONE

;

//here we adopt the following strtegy: a list to represent disjunctive of predicates:




letrec matchFormLs  symIndice  typeval2StrTab env [] =   env
/\	 matchFormLs  symIndice  typeval2StrTab env ((ba1,ba2): ls) = 
	 let env'=(matchForm  symIndice  typeval2StrTab  env (  ba1,  ba2)) in
	 env'=NONE=>NONE| 
	 matchFormLs  symIndice typeval2StrTab env' ls
;   



letrec normForm typeval2StrTab  (orList formulaList)=
   orList (normalize typeval2StrTab formulaList)

/\ normForm typeval2StrTab  (implyForm ant1 cons1) =
   normForm typeval2StrTab (orList [dualNeg ant1, cons1])

/\ normForm typeval2StrTab  (andList formulaList)=
   andList (normalize typeval2StrTab formulaList)

/\ normForm typeval2StrTab (eqn l r)=eqn l r

/\ normForm typeval2StrTab (neg f)=neg f;
  
//For a parameterized varaible, we do not print the index 1 into the string, 
//namely "n=C ->!n=C" is generated for the above formula;  after deciding the character string equal, 
//we try to unify the two formulae
//****************************************************************************************************************************************** 
   
forward_declare {formula2SmtStr::(int, string) htbl -> formula -> string}; 
let var2SmtStr  (Global v)=v
/\   var2SmtStr  (Param v i)=" ("^v^" "^(int2str i)^") " 
;

letrec exp2SmtStr  typeval2SmtStrTab  (Var var)=var2SmtStr var
/\ exp2SmtStr  typeval2SmtStrTab  (Const i)=
         enum2Str  typeval2SmtStrTab i
	   
//(ite (and (= x!1 11) (= x!2 false)) 21 0)
/\ exp2SmtStr typeval2CharacterStrTab (iteForm f e1 e2)=
	  "(ite "^(formula2SmtStr  typeval2CharacterStrTab f)^ "   "^
	    "  "^(exp2SmtStr typeval2CharacterStrTab e1)^  "  "^   
	   "  "^(exp2SmtStr typeval2CharacterStrTab e2)^" )"   ;


//let assignment2SmtStr  typeval2SmtStrTab (Assign v val0)
//    =(var2SmtStr v)^ = ^(exp2SmtStr  typeval2SmtStrTab val0);


letrec formula2SmtStr  typeval2SmtStrTab (eqn l r)
   = " (= "^(exp2SmtStr  typeval2SmtStrTab l)   ^" "^ (exp2SmtStr  typeval2SmtStrTab r)^") "
   
/\ formula2SmtStr  typeval2SmtStrTab (andList frms)
   =itlist (\e.\str. " (and "^(formula2SmtStr  typeval2SmtStrTab e) ^"   "^str^") ") frms " true "  
   
/\ formula2SmtStr  typeval2SmtStrTab (neg frm)=
     " (not " ^(formula2SmtStr  typeval2SmtStrTab  frm)^") "
    
///\ formula2SmtStr  typeval2SmtStrTab (andList [form])=
//    (formula2SmtStr  typeval2SmtStrTab form)
    
/\ formula2SmtStr  typeval2SmtStrTab (orList frms)=
    itlist (\e.\str. " (or "^(formula2SmtStr  typeval2SmtStrTab e) ^"   "^str^") ") frms " false "   

/\  formula2SmtStr  typeval2SmtStrTab (implyForm  f1 f2)
   =" (=> "^(formula2SmtStr  typeval2SmtStrTab f1)^"  "^(formula2SmtStr  typeval2SmtStrTab f2)^") "
   
/\ formula2SmtStr  typeval2SmtStrTab (forallForm  N pf)
   = formula2SmtStr  typeval2SmtStrTab  (andList (map pf (down N)))
   
/\ formula2SmtStr  typeval2SmtStrTab (chaos)
   = "true"  
   
/\   formula2SmtStr  typeval2SmtStrTab (miracle)
   = "false"     ;
        	
        	
let createThyDef aritTable  typeTable typeNameTab enumValTab fileName=
	let enumTypeDef=createSmtScalarDef  typeNameTab enumValTab in
	let funcDef=createSmtFunc  aritTable  typeTable typeNameTab in
	let outf=fopen (fileName^".temp") "w" in
	fputs outf enumTypeDef fseq
	fputs outf funcDef fseq
//	print "closef\n" fseq
	fclose outf;
	
let substVar env ( Global vname)=Global vname
     
/\ substVar env ( Param vname i)=
    mem i (tbl_keys env) => Param vname (tbl_element env i)  |( Param vname i); 

let substExp env (Const i)=
  Const i
     
/\substExp env (Var v)=
  Var (substVar env v);

  
letrec substForm   env ((eqn l r)) =
   eqn (substExp env l) r
     
/\  	substForm   env   (andList formList) =
      andList (map (substForm env) formList)

/\    substForm   env  (neg f1)  = neg ( substForm   env  f1)

/\    substForm   env ( (orList formList))=
       orList (map (substForm env) formList)
    		
/\  	substForm    env (implyForm ant1 cons1) =
     implyForm (substForm    env  ant1) (substForm    env cons1)
     
/\ substForm    env (forallForm N pf) =
     andList (map  (substForm    env)  (map pf (down N)))  ;	

let smtDecide enumValTab fileName inv1 inv2=
//	  print (fileName^"\n") fseq
	  let Inv=neg (implyForm inv1 inv2) then   
    let invStr=formula2SmtStr  enumValTab Inv then
    let assertStr="(assert "^invStr^")\n" in
     print "***********\n" fseq
    print  assertStr fseq
    
     print "***********\n" fseq
    let fin = fopen (fileName^".temp") "r"    then
    let fout = fopen (fileName^".tmp") "w"    then
    rec_copy fin fout fseq
    (fprintf fout "%s" assertStr) fseq
     fputs fout "(check-sat)" fseq
     fclose fout  fseq
     fclose fin  fseq
    // let cmd=(sprintf "z3 -smt2 %s.tmp > %s.result" (fileName, fileName)) in
    
     let cmd=(sprintf "%s -smt2 %s.tmp > %s.result" (z3PathName, fileName, fileName)) in
		// print "call z3 to do ...\n" fseq
		 val (ret,msgs) = exec cmd in
     print ((int2str ret) ^"\n") fseq
     let fresult=fopen (fileName^".result") "r" in
     let str=fgets fresult in
      print (str^"\n") fseq
   //   fgetc stdin fseq
		 let unsat=str_is_prefix  "unsat"  str then
		 fclose fresult fseq
		 unsat ;
 	
 	
let invImply  symIndice typeval2StrTab tempName inv1 inv2=
 //  print "enter invImply\n" fseq
  let inv1=normForm typeval2StrTab inv1 in
  let inv2=normForm typeval2StrTab inv2 in
  
 
  //print (formula2str typeval2StrTab inv1) fseq
 //  print "<------->\n" fseq
 // print (formula2str typeval2StrTab inv2) fseq
///	print "?-------\n" fseq
  let env=SOME (tbl_create 100) in
  let env=matchForm   symIndice  typeval2StrTab env (inv1, inv2) in
  env=NONE => F|
  let env=getReal env in
  let inv1=substForm env inv1 in
  smtDecide typeval2StrTab tempName inv1 inv2;
  
  

//let isimpliedByOldInv  symIndice  typeval2StrTab tempName inv invs=
//  let oldInvs=filter (\inv'. invImply  symIndice  typeval2StrTab tempName inv' inv) invs then
//  let noemptyR=NOT (empty oldInvs) then
//  noemptyR =>
//	(SOME (hd oldInvs))|NONE;
	

let isimpliedByOldInv   symIndice   typeval2StrTab tempName inv invs=
  let oldInvs=filter (\inv'. invImply   symIndice  typeval2StrTab tempName inv' inv ) invs then
  let noemptyR=NOT (empty oldInvs) then
  let tbl=SOME (tbl_create 2) then
	( noemptyR,  (noemptyR =>SOME (hd oldInvs)|NONE),
	(noemptyR => (matchForm   symIndice   typeval2StrTab tbl ( (hd oldInvs),inv) )|NONE));
		
	
let implySomeOldInv  symIndice 	typeval2StrTab tempName inv invs=
	filter (\inv'. invImply  symIndice  typeval2StrTab tempName inv inv') invs;
	
	
let tautlogy typeval2StrTab tempName inv=
  val (implyForm inv1 inv2) =inv in
  //let inv1=normForm typeval2StrTab inv1 in
  //let inv2=normForm typeval2StrTab inv2 in
 // print ("tautlogy inv1:="^(formula2str  typeval2StrTab inv1)^"\n") fseq
  
 // print ("tautlogy inv2:="^(formula2str  typeval2StrTab inv2)^"\n") fseq

  smtDecide typeval2StrTab tempName inv1 inv2;	

let decide   symIndice   fileName smtTemp enumTab  invsLib inv=
	  tautlogy enumTab smtTemp inv=> (T,F,T,0,chaos,NONE) |
	   val (found, oldInvOpt,envOpt)=  isimpliedByOldInv   symIndice  enumTab smtTemp inv invsLib in
     //let found= ( ) then
         (found )
         => 
        val (SOME inv'')=oldInvOpt in
        val (SOME symRel)=envOpt in
         //(taut, isImplied, isInv,No,pre)
        (F,T,T , 0,inv'',envOpt ) |
    
  //  print (fileName^"\n") fseq
    let fin = fopen (fileName^".m") "r"    then
    let fout = fopen (fileName^".tmp.m") "w"    then
    (rec_copy fin fout fseq
    (fprintf fout "%s" (form2MurphiInv enumTab inv)) fseq
  //   print ("|--------------"^(form2MurphiInv enumTab inv)^"------------------\n") fseq
     fclose fout  fseq
     fclose fin  fseq
     
     let cmd=(sprintf "%s  %s.tmp.m" (cmurphiDir,fileName)) in
    // let cmd=(sprintf "/home/lyj/cmurphi5.4.9/src/mu  %s.tmp.m" fileName) in
  //   print ("\n"^cmd^"\n") fseq
     val (ret,msgs) = exec cmd in
     ret != 0 => eprintf "mu failed with message(s):\n%S\n" msgs |
      print ("\n"^(int2str ret)^"\n") fseq
     let cmd=(sprintf "make" ) in
  //   print ("\n"^cmd^"\n") fseq
     val (ret,msgs) = exec cmd in
     ret != 0 => eprintf "make\n" msgs |  
     let cmd=sprintf  " ./%s > %s.result "  (fileName,fileName) in
     val (ret,msgs) = exec cmd in
      // ret != 0 =>  error "cache failed with message(s):\n%S\n" msgs |() fseq
      print (int2str ret) fseq
     let fresult=searchSuc (fileName^".result") in
      (F,F,fresult,0,chaos,NONE));

let form2MurphiInv enumTab inv=
    "ruleset i:client do\n"^ "   invariant \"coherent\" \n"^ (formula2str enumTab inv)^"\n"^"end;\n";

let var2SmvStr  (Global v)=v
/\   var2SmvStr  (Param v i)="Node[" ^(int2str i)^ "]."^v ;

let exp2SmvStr  typeval2StrTab  (Var var)=var2SmvStr  var
/\ exp2SmvStr  typeval2StrTab  (Const i)=
         enum2Str  typeval2StrTab i;

letrec formula2SmvStr  typeval2StrTab (eqn l r)
   = "( "^(exp2SmvStr typeval2StrTab l)^ "=" ^ (exp2SmvStr   typeval2StrTab r)^") "

///\ formula2SmvStr  typeval2StrTab (andList [frm])=formula2SmvStr  typeval2StrTab \\frm ^ (formula2SmvStr  typeval2StrTab frm)
   
/\ formula2SmvStr  typeval2StrTab (andList (frms))=
   frms=[]=>"true"|
   let str=(itlist (\e.\str. (formula2SmvStr  typeval2StrTab e) ^" & "^str) frms "" ) in
   //let strs=explode str in
   //let str=implode (
   "( "^(str_substr str 1 (strlen str -2))^") "


/\ formula2SmvStr  typeval2StrTab (neg frm)=
     " (!" ^(formula2SmvStr  typeval2StrTab  frm)^") "
    
///\ formula2SmvStr  typeval2StrTab (andList [form])=
//    (formula2SmvStr  typeval2StrTab form)
    
/\ formula2SmvStr  typeval2StrTab (orList frms)=
   let str= itlist (\e.\str. (formula2SmvStr  typeval2StrTab e) ^" | "^str) frms  ""  in
   "( "^ (str_substr str 1 (strlen str -2))^") "  

/\  formula2SmvStr  typeval2StrTab (implyForm  f1 f2)
   ="( "^(formula2SmvStr  typeval2StrTab f1)^" -> "^(formula2SmvStr  typeval2StrTab f2)^") "
   
/\ formula2SmvStr  typeval2StrTab (forallForm  N pf)
   =formula2SmvStr  typeval2StrTab (andList (map pf (down N)))
   
/\formula2SmvStr  typeval2StrTab chaos="true";

letrec existResultFile fileName=
	let fresult= (SOME (fopen fileName "r" )  catch NONE) then
	fresult =NONE =>existResultFile fileName
	| val (SOME fp)=fresult in
     let result=fgets fp then 
    // print result fseq
     fclose fp fseq
     let cmd=("rm res_inv") then 
     val (ret,msgs) = exec cmd in 
      ret != 0 => eprintf "rm  failed with message(s):\n%S\n" msgs |
     //print "rm succedd\n"  fseq 
     SOME result ;

let decideBySmv fileName enumTab inv=
    
    let fout = fopen ("trans_inv") "w"    then
    
(
    //1. generating the invariant description in SMV format, added into murphi code
    (fprintf fout "%s" (formula2SmvStr enumTab inv)) fseq
    // print ("|--------------"^(formula2SmvStr  enumTab inv)^"------------------\n") fseq
     fclose fout  fseq

     let cmd=("./transinv.sh") then  
    val (ret,msgs) = exec cmd in  
     
     // 2. system call expect to check property
     
     let result=existResultFile "res_inv" then
	   val (SOME result)=result in
    //  print result fseq
     
      result="Is_Inv"=>T | F);






letrec  chooseOne   symIndice   template smtTemp enumTab invsLib cons0 (pre:pres)=
 
  val (taut, isImplied, isInv,No,oldInv,symRelOpt)= decide   symIndice  template smtTemp enumTab invsLib (implyForm pre cons0)  in
  	
  isInv =>SOME (taut, isImplied, isInv,No,oldInv,symRelOpt,pre)
   |  chooseOne   symIndice    template smtTemp enumTab invsLib cons0 pres
    
/\  chooseOne   symIndice   template smtTemp enumTab invsLib  cons0 []=
   NONE;

letrec removeOne   symIndice  template smtTemp enumTab invsLib  cons0 (pre:pres) necessary=
   val (taut, isImplied, isInv,No,oldInv,symRelOpt)= decide   symIndice  template smtTemp enumTab invsLib  (implyForm (andList (pres@necessary)) cons0) in
   isInv=>

    removeOne   symIndice   template smtTemp enumTab invsLib  cons0 (pres) necessary

    | removeOne   symIndice   template smtTemp enumTab invsLib  cons0 (pres) (necessary@[pre])

/\ removeOne   symIndice   template smtTemp enumTab invsLib   cons0 [] necessary=
   val (taut, isImplied, isInv,No,oldInv,symRelOpt)= decide   symIndice   template smtTemp enumTab invsLib (implyForm (andList (necessary)) cons0) in
  	
  isInv =>SOME (taut, isImplied, isInv,No,oldInv,symRelOpt,(andList necessary)) |NONE;

//inv=home_current_command=emptyC => !channel2_4[1]=invalidate
//home_current_client=2 & rule=  home_current_command = req_shared
//      & !home_exclusive_granted & channel2_4[home_current_client] = emptyC
// ==>
//      begin
//       home_sharer_list[home_current_client] := true;
//       home_current_command := emptyC;
//       channel2_4[home_current_client] := grant_shared;
//      end;

let policy1   symIndice  dist template smtTemp enumTab invsLib cons0 pres=
   let parasIncons0=paraIndexsOfForm  dist cons0 in
   let parasInPres=flat (map (paraIndexsOfForm dist) pres) in
   empty (  parasIncons0 intersect parasInPres)=>
   let presOnGlobal=   filter (\f. empty (paraIndexsOfForm dist f)) pres in
   let inv=implyForm (andList presOnGlobal) cons0 in
   val (taut, isImplied, result,No,oldInv,symRelOpt)= decide    symIndice  template smtTemp enumTab invsLib  inv in 
   result =>SOME (taut, isImplied, result,No,oldInv,symRelOpt,(andList presOnGlobal))| NONE  
   |NONE ;

let assign2Form (assign v val0)=
    eqn (Var v) val0; 


//inv=home_current_command=req_shared & home_exclusive_granted=false  ->  (!channel2_4[2]=invalidate) *****
//rule=channel3[3]=invalidate_ack &  (!home_current_command=emptyC)   ==>
//channel3[3]=emptyC & home_sharer_list[3]=false & home_exclusive_granted=false &
//one example need policy2
//
let policy2   symIndice  template  smtTemp enumTab invsLib  cons0 pres  assignOnGlobal=
  
   let enhancedPres=map (\f. andList [f ,assignOnGlobal]) pres in
   chooseOne    symIndice   template smtTemp enumTab invsLib  cons0 enhancedPres;

//inv=( ( ( channel3[3]=invalidate_ack)  &  (!( home_exclusive_granted=false) )  )  ->  (!( channel2_4[2]=invalidate) ) ) *****
//rule=( ( channel2_4[3]=invalidate)  & ( channel3[3]=emptyC)  )  ==>
//channel2_4[3]=emptyC & channel3[3]=invalidate_ack & cache[3]=invalid &
//let policy3
	
//1.make the form to a normal form---, which satisfies that
//(a)the symmetry between two assertion
//channel2_4[1]=grant_exclusive -> !cache[2]=shared   =
// 	channel2_4[2]=grant_exclusive -> !cache[1]=shared
 	
//channel2_4[1]=grant_exclusive -> !cache[2]=shared   =
// 	cache[2]=shared  -> !channel2_4[1]=grant_exclusive 	
//(b)For implication
// channel2_4[1]=grant_exclusive -> cache[2]=invalid
//  channel2_4[1]=grant_exclusive -> !cache[2]=shared
  
//our strategy , first normalize, then unify the quantifier by only match the left side
//invsLib:Invariants has been checked pllus inv itself
//newInvs:Invs has not been checked
//We construct new invariants according to policies as follows:
//inputs: a consequent cons0, a list of premises: pres, 
//outputs: an formula ant' such that ant' --> cons0 is also a new invariant 
//ant' is a conjunction, conjunctals of ant' <= pres;
//policy1: the simplest one, select one premise from pres as ant'
//for instance1: cons0=( home_sharer_list[1]=true); pres=[(channel2_4[cl] = grant_shared)]statement2Env statement env
//we directly select (channel2_4[cl] = grant_shared) as ant' ;

//policy3:delete some unnecessary pre-conditions:
//for instance2:
//pres=[ home_current_command = req_shared, !home_exclusive_granted, channel2_4[1] = empty,home_current_client=1];
//cons=Neg ( channel3[1]=invalidate_ack) ;


let choose   symIndice  template  smtTemp enumTab invsLib  cons0 pres statements ant=
   //print "\nenter policy choose\n" fseq
//policy1
   let preOnStatements=map assign2Form (filter (\S. val (assign v val0) =S in
                                           empty (  (paraIndexOfVar v) intersect (paraIndexsOfForm dist ant))  ) statements ) then 
   let assignStatementOnGlobals=filter (\S. val (assign v val0) =S in
                                            empty (paraIndexOfVar v) ) statements then
   let globalAnts=                                        
         assignStatementOnGlobals=[]=>[]|
        // val [assignStatementOnGlobal]=assignStatementOnGlobals in
         map  neg  (map assign2Form assignStatementOnGlobals) then                                       
   let result=chooseOne   symIndice   template   smtTemp enumTab invsLib  cons0 (pres@globalAnts)  then
   (result!=NONE) =>result|
//policy2
    let result=policy1   symIndice   dist   template   smtTemp enumTab invsLib   cons0 pres then
      (result!=NONE) =>result|
     //  print "\nenter policy2 \n" fseq
       let result=
         (globalAnts=  []=>NONE |
         let globalAnt=hd globalAnts  in
         policy2   symIndice   template  smtTemp enumTab invsLib   cons0 pres globalAnt) catch NONE in
      result!=NONE => result
      |let ants=andList2ands ant then
       let ants=filter (\f. empty (paraIndexsOfForm dist f)) ants then
       let result=(ants=[])=>NONE|
       val [antOnGlobal]= ants in
           policy2   symIndice   template  smtTemp enumTab invsLib   cons0 pres antOnGlobal then
       (result!=NONE) =>result| removeOne   symIndice    template  smtTemp enumTab invsLib  cons0 pres [];



letrec tbl_deletes tbl []=tbl
/\tbl_deletes tbl (k:ks)=
   let tbl' =((tbl_delete tbl k)  catch tbl) then tbl_deletes tbl' ks;


//here f must be a andList form or eqn
let statementEnableForm1  typeTable  typeval2StrTab tempName statement f preCond=
    //  print ((formula2str typeval2StrTab f) ^"enable\n") fseq
      
      let setOff=setify (varOfForm f)  then
    //  let setOfS=setify (varOfStatement statement) then
      let env=SOME (tbl_create 20) then
      let env=statementPartlyEnableForm  typeTable  env statement f then
      env=NONE =>(F,NONE)|
      let changedVars=tbl_keys (getReal env) then
  //    printStrList (map  (formula2str typeval2StrTab)    (andList2ands f)) fseq
      let isNotDeciseEqn form= val [( vname)]= varOfForm  form in 
                                  NOT (mem vname changedVars) then
      let undecideForms=filter isNotDeciseEqn (andList2ands f) then
      let decide=    smtDecide typeval2StrTab tempName preCond (andList undecideForms) then
      print (bool2str 10 decide) fseq
     // val (SOME env)=env in
     // let env=tbl_deletes env  setOff then
      (decide,  env);
      
//here f must be a andList form or eqn
 let statementEnableForm  typeTable  typeval2StrTab tempName statement f preCond=    
   let env= (tbl_create 20) then
    let env=form2Env typeTable preCond env then
    let env=statement2Env statement env then
    let cond=checkConjsInEnv (andList2ands f) env then
    (cond, SOME env);

let impInvNorm inv=
//   let recover s=print
   (val (implyForm ant cons0)=inv in
   val (neg (andList conjunctals ))=cons0 in
   length conjunctals >1 => implyForm (andList conjunctals ) (neg ant) 
   | inv) catch inv;

let statementDisableForm1  typeTable  typeval2StrTab tempName   statement f preCond=
     let setOff=setify (varOfForm f)  then
    //  let setOfS=setify (varOfStatement statement) then
      let env=SOME (tbl_create 20) then
      print "disable\n" fseq
      let env=statementPartlyDisableForm  typeTable  env statement f then
      env!=NONE =>(T,env)| 
       let setOfS=setify (varOfStatement statement) then
       let isNotDeciseEqn form= val [( vname)]= varOfForm  form in 
                                  NOT (mem vname setOfS) then
      let undecideForms=filter isNotDeciseEqn (andList2ands f) then
       let decide=    smtDecide typeval2StrTab tempName preCond (neg (andList undecideForms)) then
      
       print (bool2str 10 decide) fseq
     //  val (SOME env)=env in
     //  let env=tbl_deletes env setOff then
      (decide, env);
      
let statementDisableForm  typeTable  typeval2StrTab tempName statement f preCond=    
   let env= (tbl_create 20) then
   let env=form2Env typeTable preCond env then
   let env=statement2Env statement env then
   let cond=checkDisableConjsInEnv (andList2ands f) env then
  (cond, SOME env);      


let var2ByPramNormlize  symIndices  paraTab (Global v) =(Global v)
/\   var2ByPramNormlize  symIndices   paraTab (Param v i)= mem i symIndices => (Param v (tbl_element paraTab i)) | (Param v i);

forward_declare {formula2ByPramNormlize ::int-> int list ->(int, int) htbl -> formula -> formula};

letrec exp2ByPramNormlize  dist  symIndices   paraTab  (Var var)=Var (var2ByPramNormlize  symIndices   paraTab  var)
/\ exp2ByPramNormlize dist  symIndices   paraTab (Const i) =    
	(i< dist) AND (mem i symIndices) => (Const (tbl_element paraTab i)) |    (Const i)
/\ exp2ByPramNormlize  dist  symIndices   paraTab (iteForm f e1 e2)=
  iteForm (formula2ByPramNormlize  dist  symIndices   paraTab f) (exp2ByPramNormlize  dist  symIndices    paraTab e1) (exp2ByPramNormlize  dist  symIndices   paraTab e2);


//let assignment2ByPramNormlize  dist  paraTab (Assign v val0)
//    =(var2ByPramNormlize paraTab v)^ = ^(exp2ByPramNormlize  paraTab val0);


letrec formula2ByPramNormlize  dist  symIndices    paraTab (eqn l r)
   = eqn (exp2ByPramNormlize  dist  symIndices    paraTab l)  (exp2ByPramNormlize  dist   symIndices   paraTab r)
   
/\ formula2ByPramNormlize  dist  symIndices   paraTab (andList frms)
   =andList (map (formula2ByPramNormlize  dist  symIndices   paraTab  )   frms ) 
   
//please note that the formulae will be only allowed when negation is at the    nested level
/\ formula2ByPramNormlize  dist  symIndices   paraTab (neg frm)=
      neg (formula2ByPramNormlize  dist  symIndices   paraTab  frm)
    
 
    
/\ formula2ByPramNormlize  dist  symIndices   paraTab (orList frms)
    =orList (map (formula2ByPramNormlize  dist  symIndices   paraTab  )   frms )   

/\  formula2ByPramNormlize  dist  symIndices   paraTab (implyForm  f1 f2)
   =implyForm  (formula2ByPramNormlize  dist  symIndices     paraTab f1) (formula2ByPramNormlize  dist  symIndices   paraTab f2)
   
/\  formula2ByPramNormlize  dist  symIndices   paraTab (forallForm  N pf)=
   andList (map  (formula2ByPramNormlize  dist  symIndices   paraTab) (map pf  (down N)))  ;
   


letrec statement2ByPramNormlize  dist  symIndices   paraTab (assign v val0)
    =assign (var2ByPramNormlize  symIndices      paraTab v) (exp2ByPramNormlize  dist  symIndices  paraTab val0) 

    
/\statement2ByPramNormlize  dist  symIndices   paraTab (parallel SL)=
  parallel (map  (statement2ByPramNormlize  dist  symIndices   paraTab) SL) 
  
/\statement2ByPramNormlize  dist  symIndices  paraTab (forallStatement N PSL)=
  parallel (map  (statement2ByPramNormlize  dist  symIndices   paraTab) (map PSL (down N)));



let rule2ByParamNormlize  dist  symIndices  paraTab (guard f S)=
   guard (formula2ByPramNormlize dist  symIndices  paraTab f) (statement2ByPramNormlize dist  symIndices  paraTab S);
   

letrec list2Tab  [] tab i=tab
/\ list2Tab (x:xs) tab i=list2Tab xs (tbl_insert tab x i)   (i + 1);

let swapPair (a,b)=(b,a);
    
let paraNormlize dist symIndices inv0=
  let paras=paraIndexsOfForm dist inv0 then
  let symParas=filter (\i.mem i symIndices) symIndices then  
  let symRel=(list2Tab  paras (tbl_create 2) 1) then
  let symRelInv=tbl_insert_assoc_list (tbl_create 2) (map swapPair (tbl_values symRel)) then
   (formula2ByPramNormlize dist  symIndices  symRel inv0,symRelInv);   
   
 // (length symParas)<2 =>inv0 |
//   formula2ByPramNormlize  dist  symIndices  (list2Tab  paras (tbl_create 2) 1) inv0;
   
   
//let paraNormlize  inv0=
//  let paras=paraIndexsOfForm dist inv0 then
//  let symRel=(list2Tab  paras (tbl_create 2) 1) then
  //el 1 paras=1=>inv0 |
  //  let symRel=(tbl_length symRel)=1=>(tbl_elemnt tbl 1=1) => tbl_insert symRel 2 2|tbl_insert symRel (tbl_element symRel  ) 
 // let symRelInv=tbl_insert_assoc_list (tbl_create 2) (map swapPair (tbl_values symRel)) then
//   (formula2ByPramNormlize  symRel inv0,symRelInv);   


//let casualRel=causal   (paraRule paras inv invParas ruleType DisableOrEnable inv' ant')
lettype disAbleOrEnableType=Enable | Disable;

lettype ruleType=invHoldForRule1 disAbleOrEnableType | 
                 invHoldForRule2 |
                 invHoldForRule3 formula formula  |
                 invHoldForRule4 formula formula formula bool bool   |
                 invHoldForRule5 formula  ;

 let test1 typeval2CharacterStrTab fiveTuple=
 val (paraRule1, paras1, inv1, invParas1, invHoldType1) =fiveTuple in 
(str_is_prefix
"channel2_4=invalidate -> !home_exclusive_granted=false & home_current_command=req_shared &"  
 (formula2CharacterStr typeval2CharacterStrTab inv1)  );
 

//forward_declare
//	{keyWithfiveTuple2Strs:: int -> int list -> (string, int) htbl -> stream -> (int, string) htbl ->
//(string # (*a -> rule # *a # formula # *b # ruleType) list) -> void};

let isConst val0=( val (Const vc)= val0 in T) catch F;

let envItem2Str enumTab (v,val0)=(var2Str v)^(exp2str enumTab val0);

let printEnv enumTab  env=
   printStrList (map (envItem2Str  enumTab ) (tbl_values env));
   
letrec  chooses    symIndice   template  smtTemp enumTab invsLib  [] premises statements ant= NONE
/\  chooses   symIndice   template smtTemp enumTab invsLib (cons0:consS) premises statements ant= 
     fputs fdebug ( "chosses cons0="^(formula2str enumTab cons0)^"*****\n")  fseq  
     let try1=choose   symIndice   template  smtTemp enumTab invsLib  (cons0) premises statements ant then
       try1= NONE => chooses   symIndice   template smtTemp enumTab invsLib (consS) premises statements ant |
       SOME (cons0, getReal try1);
       
letrec simpTaut (eqn l r)= l=r=>[ ]| 
                           (isConstExp l) AND (isConstExp r)=> [miracle] |  [(eqn l r)]
/\ simpTaut (andList frms)= 
   let mid=(filter (\f. (f!=chaos))  (flat (map simpTaut frms))) then mid
   //mem miracle mid=>[miracle]
 
/\ simpTaut (neg frm)=
   let mid=(simpTaut frm) then
   mid=[miracle]=> [] | map neg  mid
/\ simpTaut chaos=[]
/\ simpTaut (orList  forms)=[orList  (flat (map simpTaut  forms))]
/\ simpTaut (forallForm N fl)=flat (map simpTaut (map fl (down N)))
/\ simpTaut (forallForm N fl)=[];       
       
 
      
//case 2, when statement does not change any variable in inv, then does not add any new invariants
letrec dealWithCase2 ruleTable  enumTab fiveTuple ((g,inv):obligations) (newInvs,relLib) =
       
	      val (paraRuleName, paras,g', inv0, invParas, _)=fiveTuple in
	       let paraRule=tbl_element ruleTable paraRuleName then
         let hdTab=(paraRuleName, paras,g, inv0, invParas, invHoldForRule2) then  
         fputs fdebug "branch 2 " fseq     
          fputs fdebug   ("******************************************************\n") fseq
         fputs fdebug ("inv:="^(formula2str  enumTab inv)^"\n") fseq
         fputs fdebug  ("rule="^(rule2Str enumTab (paraRule (el 1 paras) (el 2 paras)))^"*****\n") fseq
         fputs fdebug ("inv0:="^(formula2str  enumTab inv0)^"\n") fseq
         fputs fdebug   ("******************************************************\n\n\n") fseq  
         let midResult=  (newInvs, relLib@[hdTab])  then
         
         dealWithCase2  ruleTable   enumTab  fiveTuple ( obligations) midResult
 /\   dealWithCase2 ruleTable  enumTab  fiveTuple [] (newInvs,relLib) =   (   newInvs,relLib);

//case when enabled consequent or disable antecedent              
letrec dealWithCase1 ruleTable  enumTab fiveTuple ((g,inv):obligations) (newInvs,relLib) =
 
	      val (paraRuleName, paras,g', inv0, invParas, _)=fiveTuple in
	      
	       let paraRule=tbl_element ruleTable paraRuleName then
         let hdTab=(paraRuleName, paras,g, inv0, invParas, invHoldForRule1 Enable) then
         let midResult=  (newInvs, relLib@[hdTab]) then
         fputs fdebug "branch 1 " fseq 
         fputs fdebug   ("******************************************************\n") fseq
         fputs fdebug ("inv:="^(formula2str  enumTab inv)^"\n") fseq
         fputs fdebug  ("rule="^(rule2Str enumTab (paraRule (el 1 paras) (el 2 paras)))^"*****\n") fseq
         fputs fdebug ("inv0:="^(formula2str  enumTab inv0)^"\n") fseq
         fputs fdebug   ("******************************************************\n\n\n") fseq
         dealWithCase1  ruleTable   enumTab fiveTuple ( obligations) midResult
         
 /\   dealWithCase1 ruleTable  enumTab fiveTuple [] (newInvs,relLib) =   (newInvs,relLib);
 
//case when enabled consequent or disable antecedent              
letrec dealWithCase3  ruleTable  dist  symIndice statement template smtTemp enumTab invsLib guardOfRule fiveTuple ((g,inv):obligations) (newInvs,relLib) =   
	     val (paraRuleName, paras,g', inv0, invParas, _)=fiveTuple in
	     
	       let paraRule=tbl_element ruleTable paraRuleName then
       let statements=parallelStatement2Statements statement then
       val (implyForm pres0 cons0)=inv in 
       
       let pres0=simpTaut pres0 then     
       let pres0=filter (\f. f !=chaos) pres0 then
       let pres0=flat (map andList2ands pres0) then
       let pres0=setify (flat (map andList2ands pres0)) then 
       let invsLib'=(setify ((inv0:newInvs)@invsLib)) then
       let gConds=andList2ands (andList (simpTaut g)) then
       print ("pres0=\n") fseq
       printStrList (map (formula2str enumTab) (setify ( pres0))) fseq
       print ("gConds=\n") fseq
       printStrList (map (formula2str enumTab) (setify (gConds))) fseq
       let result= getReal (choose   symIndice    template smtTemp  enumTab invsLib' cons0 (setify ( guardOfRule @pres0@gConds))    statements  (andList []) ) catch 
                (print  ("inv:="^(formula2str  enumTab inv)^"\n") fseq
                 print ("inv0:="^(formula2str  enumTab inv0)^"\n") fseq
                 print  ("rule="^(rule2Str enumTab (paraRule (el 1 paras) (el 2 paras)))^"*****\n") fseq 
                 error "debug")    
                 then
       val ( (taut, isImplied, isInv,No, oldInv,symRelOpt,pre))=result in
       let inv'= (implyForm pre cons0) in
       fputs fdebug "branch 3\n " fseq
       fputs fdebug   ("******************************************************\n") fseq
       fputs fdebug ("inv:="^(formula2str  enumTab inv)^"\n") fseq
        fputs fdebug ("inv0:="^(formula2str  enumTab inv0)^"\n") fseq
       fputs fdebug  ("rule="^(rule2Str enumTab (paraRule (el 1 paras) (el 2 paras)))^"*****\n") fseq
       fputs fdebug ("inv':="^(formula2str  enumTab inv')^"\n") fseq
        fputs fdebug   ("******************************************************\n\n\n") fseq
        //let emptyTab=tbl_create 2 then
        let hdTab= (paraRuleName, paras, g, inv0, invParas, invHoldForRule3 inv' pre  ) then
        let midResult=
        taut => 
        
        let hdTab= (paraRuleName, paras, g, inv0, invParas, invHoldForRule3 inv pre) then (newInvs, relLib@[hdTab]) |
        isImplied => 
        val (SOME symRel)=symRelOpt in 
        let symRel=((tbl_empty symRel)  => symId symRel | symRel) then
        let inv'=(formula2ByPramNormlize  dist symIndice  symRel oldInv) then
        let hdTab= (paraRuleName, paras,g, inv0, invParas, invHoldForRule3 inv' pre ) then
        ( newInvs, relLib@[hdTab])  |
        val (inv'',symRel)=  paraNormlize dist  symIndice   (impInvNorm inv') then   
        let inv'=(formula2ByPramNormlize  dist symIndice  symRel inv'') then
        let hdTab= (paraRuleName, paras,g, inv0, invParas, invHoldForRule3 inv' pre ) then
       // let inv''=  paraNormlize dist  symIndice  (impInvNorm inv') then
         (newInvs@[inv''], relLib@[hdTab])  then
         
      dealWithCase3 ruleTable  dist symIndice  statement template smtTemp enumTab invsLib  guardOfRule  fiveTuple obligations midResult
                
 /\   dealWithCase3 ruleTable  dist   symIndice  statement template smtTemp enumTab invsLib   guardOfRule  fiveTuple [] (newInvs,relLib) =   (   newInvs,relLib);
 
          
letrec dealWithCase4 ruleTable  dist symIndice  statement template smtTemp enumTab invsLib guardOfRule fiveTuple ((g,inv):obligations) (newInvs,relLib) =   
	     let statements =parallelStatement2Statements statement then 
	      val (implyForm ant' cons0)=inv in 
        val (paraRuleName, paras,g', inv0, invParas, _)=fiveTuple in
        
	       let paraRule=tbl_element ruleTable paraRuleName then
        let pres0=simpTaut cons0 then      
        let pres0=filter (\f. f !=chaos) pres0 then
        let pres0=setify (flat (map andList2ands pres0)) then 
        let pres0=map dualNeg pres0 then
        //let pres0=filter (\f. f !=chaos) pres0 then              
        let ant'=simpTaut ant' then        
        let invsLib'=(setify ((inv0:newInvs)@invsLib)) then
        let gConds= (let mid=simpTaut g then (mid=[])=>[]| mid) then
        let result=getReal (chooses   symIndice   template smtTemp  enumTab invsLib' (setify ((map dualNeg ( ant'))@[dualNeg (andList ant')]) )
                            (setify (guardOfRule @pres0@gConds)) statements (andList [])  
                           )   catch 
                (print  ("inv:="^(formula2str  enumTab inv)^"\n") fseq
                 print ("inv0:="^(formula2str  enumTab inv0)^"\n") fseq
                 print  ("rule="^(rule2Str enumTab (paraRule (el 1 paras) (el 2 paras)))^"*****\n") fseq 
                 printStrList (map (formula2str  enumTab) invsLib) fseq
                 error "debug")           
                           
                             then
         //val  (cons', (taut, isImplied, isInv,No, pre))=result in    
         val  (cons', (taut, isImplied, isInv,No, oldInv,symRelOpt,pre))=result in    
         
        let inv'= (implyForm pre cons') then
        fputs fdebug "branch 4 " fseq
        fputs fdebug ("inv:="^(formula2str  enumTab inv)^"\n") fseq
        fputs fdebug ("inv0:="^(formula2str  enumTab inv0)^"\n") fseq
        fputs fdebug  ("rule="^(rule2Str enumTab (paraRule (el 1 paras) (el 2 paras)))^"*****\n") fseq
        fputs fdebug ("inv':="^(formula2str  enumTab inv')^"\n") fseq 
       // print ("invLengths="^(int2str (length invsLib))^"\n") fseq
        val (paraRuleName, paras, g',inv0, invParas, _)=fiveTuple in   
        let hdTab= (paraRuleName, paras, g,inv0, invParas, invHoldForRule4 inv' pre (dualNeg cons') F F) then
           fputs fdebug "enter snd condition step\n"  fseq
        let midResult=
        (taut =>  
               
          let hdTab= (paraRuleName, paras, g',inv0, invParas, invHoldForRule4 inv' pre (dualNeg cons') T F) then 
          ( newInvs, relLib@[hdTab])
           
        |isImplied => 
           
        val (SOME symRel)=symRelOpt in 
        let symRel=((tbl_empty symRel)  => symId symRel | symRel) then
        let inv'=(formula2ByPramNormlize  dist symIndice  symRel oldInv) then
          let hdTab= (paraRuleName, paras, g,inv0, invParas, invHoldForRule4 inv' pre (dualNeg cons') F T) then
          (newInvs, relLib@[hdTab]) 
        |
        fputs fdebug "enter 5th step\n"  fseq
        fputs fdebug ("inv'FromNewInv:="^(formula2str  enumTab inv')^"\n") fseq
        let inv''= paraNormlize dist  symIndice   (impInvNorm inv') then
         val (inv'',symRel)=  paraNormlize dist  symIndice   (impInvNorm inv') then   
        let inv'=(formula2ByPramNormlize  dist symIndice  symRel inv'') then         
        let hdTab= (paraRuleName, paras, g,inv0, invParas, invHoldForRule4 inv' pre (dualNeg cons') F F) then
          (newInvs@[inv''], relLib@[hdTab]) )    then
         
      dealWithCase4 ruleTable  dist   symIndice  statement template smtTemp enumTab invsLib guardOfRule fiveTuple obligations midResult
                
 /\   dealWithCase4 ruleTable  dist  symIndice  statement template smtTemp enumTab invsLib guardOfRule fiveTuple [] (newInvs,relLib) =   (   newInvs,relLib);
 
 
 letrec dealWithCase5 ruleTable  dist   symIndice   statement template smtTemp enumTab invsLib guardOfRule fiveTuple ((g,inv):obligations) (newInvs,relLib) = 
       
       val  (implyForm preAnt preCons)=inv in
       val (paraRuleName, paras,g', inv0, invParas, _)=fiveTuple in
	       let paraRule=tbl_element ruleTable paraRuleName then
       let  preAnt=  (simpTaut preAnt) then
       let preCons=andList (simpTaut preCons) then
       let gConds=simpTaut   g then
       let inv'= (implyForm (andList (preAnt@gConds)) preCons) then
        fputs fdebug "branch 5 " fseq
        fputs fdebug  ("rule="^(rule2Str enumTab ((paraRule (el 1 paras) (el 2 paras))))^"*****\n") fseq
        fputs fdebug ("inv:="^(formula2str  enumTab inv)^"\n") fseq
        fputs fdebug ("inv0:="^(formula2str  enumTab inv0)^"\n") fseq
        fputs fdebug ("inv':="^(formula2str  enumTab inv')^"\n") fseq 
       let invsLib'=(setify ((inv0:newInvs)@invsLib)) then
       let hdTab= (paraRuleName, paras, g,inv0, invParas, invHoldForRule5 inv'  ) then
       let result=decide   symIndice   template smtTemp  enumTab invsLib'  inv' then
       
       val (  (taut, isImplied, isInv,No ))=result in 
       let midResult=
      	(taut =>
      	   
      	    let hdTab= (paraRuleName, paras, g,inv0, invParas, invHoldForRule5 inv'  ) then
      	 
           fputs fdebug ("inv'tautlogy:="^(formula2str  enumTab inv')^"\n") fseq
          
            (newInvs, relLib@[hdTab])
        | 
        isImplied => 
          
         
         let hdTab= (paraRuleName, paras,g, inv0, invParas, invHoldForRule5 inv'  ) then
         (newInvs,relLib@[hdTab])
        |
        fputs fdebug "enter 5th step\n"  fseq
        fputs fdebug ("inv'FromNewInv:="^(formula2str  enumTab inv')^"\n") fseq
        val (inv'',symRel)= paraNormlize dist  symIndice   (impInvNorm inv') in 
        
          (newInvs@[inv''], relLib@[hdTab])  )  then
  dealWithCase5 ruleTable  dist  symIndice  statement template smtTemp enumTab invsLib guardOfRule fiveTuple obligations midResult
                
 /\   dealWithCase5 ruleTable  dist symIndice  statement template smtTemp enumTab invsLib guardOfRule fiveTuple [] (newInvs,relLib) =   (   newInvs,relLib);          

let obligation2Str enumTab (g,inv)=
   ("g="^(formula2str enumTab g)^"***** ")^
   ("inv="^(formula2str enumTab inv)^"*****\n")      ;

   
      
let findInvsFromRule' ruleTable dist  symIndice   typeTable  template smtTemp enumTab inv rule fiveTuple newInvs invsLib relLib=
 //   print ("enter findInvsFromRule\n") fseq
   // let fiveTuple=
   //  val (paraRuleNameF, parasF,gF', inv0F, invParasF, invHoldTF)=fiveTuple in
   //  (tbl_element ruleTable paraRuleNameF,parasF,gF', inv0F, invParasF, invHoldTF) then
	  val (guard form  statement)=rule in 
	  val (implyForm ant cons0)=inv in
	  let obligations=setify (preCond inv statement) then
	  print ("obligation=") fseq
	  printStrList (map (obligation2Str  enumTab) obligations) fseq
	  fputs fdebug1 (itlist (defix ^) (map (obligation2Str  enumTab) obligations) "------------------\n") fseq
	  
      // val (newInvs,fiveTupleTab)=newInvsPlusfiveTupleTab in
       
        fputs fdebug   ("******************************************************\n") fseq
        fputs fdebug  ("inv="^(formula2str enumTab inv)^"*****\n") fseq
        fputs fdebug  ("rule="^(rule2Str enumTab rule)^"*****\n") fseq
        fputs fdebug   ("******************************************************\n") fseq
       
       let flagStr=(rule2Str enumTab rule)^";"^
	                 (formula2str enumTab inv)  then
	    // fputs fdebug flagStr fseq         
       //fputs fdebug  ("******************************************************\n") fseq  
       //let env=SOME (tbl_create 20) in
       //(test1 enumTab fiveTuple => 
      // fputs fdebug ("inv="^(formula2str enumTab inv)) |()) fseq
       
   //delete uunchanged inv
   
   let obligations2= (filter (\(g,inv').  (inv =inv')) obligations) then
   print ("obligations2=") fseq
	  printStrList (map (obligation2Str  enumTab) obligations2) fseq
	  
   let midResult=dealWithCase2 ruleTable enumTab  fiveTuple (obligations2) (newInvs,relLib) then
   
    let remainder=  (obligations subtract obligations2) then 
    
    remainder =[] =>midResult|
   
   //delete enabled consequent or disable antecedent 
   
   let enableCheckCons0 (g,inv')=tautlogy enumTab smtTemp (implyForm (andList [form, g]) inv')  then   
   
   let obligations1=(filter enableCheckCons0 remainder) then
   // print ("obligations1=") fseq
	 // printStrList (map (obligation2Str  enumTab) obligations1) fseq
   
   let midResult=dealWithCase1 ruleTable enumTab fiveTuple (obligations1) midResult then 
   
   let remainder=remainder subtract obligations1 then
   
   remainder =[] =>midResult|
   
   let consNotChange (g,(implyForm ants0 cons1))=(cons0 =cons1) then
   
   let obligations3=filter consNotChange remainder then
   //print ("obligations3=") fseq
	 // printStrList (map (obligation2Str  enumTab) obligations3) fseq
    
   
   let midResult=dealWithCase3 ruleTable dist   symIndice  statement template smtTemp enumTab invsLib  (andList2ands form) fiveTuple (obligations3) midResult then 
   
    let remainder=remainder subtract obligations3 then
    
    remainder =[] =>midResult|
    
    let antNotChange (g,(implyForm ants0 cons1))=(ants0 =ant) then
    
    let obligations4=filter antNotChange remainder then
    
    print ("obligations4=") fseq
	  printStrList (map (obligation2Str  enumTab) obligations4) fseq
    
    let midResult=dealWithCase4 ruleTable  dist  symIndice  statement template smtTemp enumTab invsLib  (andList2ands form) fiveTuple (obligations4) midResult then    
    
    let remainder=remainder subtract obligations4 then
   
    remainder =[] =>midResult|
    
    dealWithCase5 ruleTable dist   symIndice  statement template smtTemp enumTab invsLib  (andList2ands form) fiveTuple remainder midResult;
        
//non_lazy findInvsFromRule';       
 
// let findInvsFromRule template smtTemp enumTab inv rule fiveTuple newInvs invsLib relLib        
         
letrec findInvsFromRules ruleTable dist   symIndice   typeTable  template smtTemp enumTab inv []  fiveTuples newInvs  invsLib relLib=(newInvs,relLib)
/\    findInvsFromRules  ruleTable dist    symIndice  typeTable  template smtTemp enumTab inv (r:rs)  fiveTuples newInvs   invsLib relLib=
        //val (paraRule, paras, inv, paraOfInvs,methodPat)=hd fiveTuples in
        
      	val (newInvs',relLib')=findInvsFromRule'  ruleTable dist  symIndice   typeTable  template smtTemp enumTab inv r (hd fiveTuples)  newInvs  invsLib relLib in             
	      findInvsFromRules  ruleTable dist   symIndice   typeTable  template smtTemp enumTab inv  rs (tl fiveTuples) (newInvs') invsLib relLib'; 

letrec imaxOf [i] =i
/\	 imaxOf (i:j:is)=imax i (imaxOf (j:is));




let instantiate paraRule inv paraLs parasOfInv=
       let construct paraL=
       	 let fiveTuple=(paraRule, paraL, inv, parasOfInv, invHoldForRule2) in	
       	 (paraRule (el 1 paraL) (el 2 paraL), fiveTuple)  in
	map (construct ) paraLs;
	
let parasOfInv  dist  symIndices inv=
		let paras=paraIndexsOfForm dist inv then
		filter (\i.   (mem i symIndices)) paras;
	
let newParas  dist symIndices inv ruleParaNums=
  let paraNum=	length ( parasOfInv  dist  symIndices inv) then
   paraNum  = 0=>[[1,1]]
  |(paraNum =1) AND (ruleParaNums=1) => [[1,1],[2,1]]
  |(paraNum =1) AND (ruleParaNums=2) => [[1,1],[2,1],[3,1]]
  |[[1,2],[2,1],[3,1],[1,3],[2,3],[3,2],[3,4]];


let instantiate ruleTable paraRuleName inv paraLs parasOfInv=
       let paraRule=tbl_element ruleTable paraRuleName then
       let construct paraL=
       	 let fiveTuple=(paraRuleName, paraL, chaos, inv, parasOfInv, invHoldForRule2) in	
       	 (paraRule (el 1 paraL) (el 2 paraL), fiveTuple)  in
	map (construct ) paraLs;
	
let parasOfInv  dist  symIndices inv=
		let paras=paraIndexsOfForm dist inv then
		filter (\i.   (mem i symIndices)) paras;
	
let newParas  dist symIndices inv ruleParaNums=
  let paraNum=	length ( parasOfInv  dist  symIndices inv) then
   paraNum  = 0=>[[1,1]]
  |(paraNum =1) AND (ruleParaNums=1) => [[1,1],[2,1]]
  |(paraNum =2) AND (ruleParaNums=1) => [[1,1],[2,1],[3,1]]
  |[[1,2],[2,1],[3,1],[1,3],[2,3],[3,2],[3,4]];
		
//newParasMethod=newParas  dist symIndice        ;
//parasOfInvMethod=parasOfInv  dist  symIndice ;

let findInvsFromParaRule  dist  ruleTable parasOfInvMethod  newParasMethod ruleParasTable symIndice   typeTable  allParaSet template smtTemp enumTab  inv paraRuleName newInvs invsLib relLib=
  print paraRuleName fseq
  let ruleParaNums=tbl_element ruleParasTable paraRuleName then   
  //let paraRule=tbl_element ruleTable paraRule then
	let paras=parasOfInvMethod inv in
	let paraLs=newParasMethod inv ruleParaNums then
	let ruleAndFiveTuples = (instantiate ruleTable paraRuleName inv  paraLs paras) in 
	let rs=map fst ruleAndFiveTuples in 
	let fiveTuples=map snd ruleAndFiveTuples in
	findInvsFromRules ruleTable  dist   symIndice   typeTable  template smtTemp enumTab inv rs  fiveTuples newInvs invsLib relLib;   
	
	

		
letrec findInvsFromParaRulesByInv  dist  ruleTable parasOfInvMethod  newParasMethod ruleParasTable symIndice   typeTable  allParaSet template smtTemp enumTab  
 inv (paraRule:paraRules)  (newInvs)  invsLib relLib=
        
	val (newInvs',relLib') =findInvsFromParaRule  dist  ruleTable parasOfInvMethod newParasMethod ruleParasTable symIndice   typeTable  allParaSet template smtTemp enumTab  inv paraRule  newInvs invsLib relLib in
         findInvsFromParaRulesByInv  dist  ruleTable parasOfInvMethod newParasMethod ruleParasTable symIndice   typeTable  allParaSet template smtTemp enumTab  inv (paraRules)  newInvs'  invsLib relLib'
 
/\findInvsFromParaRulesByInv  dist  ruleTable parasOfInvMethod newParasMethod ruleParasTable symIndice      typeTable  allParaSet template smtTemp enumTab inv  []  
  newInvs invsLib relLib = (newInvs,relLib);

 //( channel2_4[1]=invalidate)  ->  (!( ( home_exclusive_granted=false)  & ( home_current_command=req_shared)  ) ) ) 




letrec findInvsFromParaRulesByInvs  dist ruleTable parasOfInvMethod  newParasMethod ruleParasTable symIndice   typeTable   allParaSet template smtTemp enumTab   [] (paraRules)      invsLib	  relLib =(invsLib,relLib)

/\ findInvsFromParaRulesByInvs dist   ruleTable parasOfInvMethod newParasMethod ruleParasTable symIndice   typeTable  allParaSet template smtTemp enumTab   (inv:Invs) (paraRules)     invsLib	 relLib =
    
     
    
    let invsLib=inv:invsLib then
  //  length invsLib=40=>(printStrList (map (formula2SmvStr  enumTab) invsLib) fseq fclose fdebug fseq error "debug")
   //|
   fputs fdebug ((formula2str enumTab   inv)^"\n") fseq
   
     print ("****************invLengths="^(int2str (length invsLib))^"*******************\n") fseq
    val (newInvs', rels)=findInvsFromParaRulesByInv  dist  ruleTable parasOfInvMethod newParasMethod ruleParasTable symIndice   typeTable  allParaSet template smtTemp enumTab  inv paraRules (Invs)  (setify(invsLib@[inv]@Invs)) relLib in
        findInvsFromParaRulesByInvs  dist  ruleTable parasOfInvMethod  newParasMethod ruleParasTable symIndice   typeTable  allParaSet  template smtTemp enumTab   newInvs' (paraRules)    (setify(invsLib@newInvs'))   rels   ;


//create definition for one enumerating values as follows:
//definition TRUE::"nat"  where [simp]: "TRUE\<equiv>  1"
let createOneEnumVal  enumValTab val0=
	let valName=tbl_element enumValTab val0 in
	sprintf "definition %s::\"nat\"  where [simp]: \"%s\\<equiv>  %d\"   \n" (valName, valName,val0);

//create all defs of this type
//definition xDomain::"nat set" where [simp]: "Bool \<equiv> {TRUE, FALSE}"
//definition xDomain::"nat set" where [simp]: "Bool \<equiv> {TRUE, FALSE}"
let createOneEnumType oneType typeName enumValTab=
	let defs=map (createOneEnumVal  enumValTab) oneType in
	let enumValDefStr=itlist (defix ^)  defs "" in
	let allVluesInStr=itlist (\a. \b. a^","^b)  (map (\val0. tbl_element enumValTab val0) oneType) ""  in
        let Str=str_substr allVluesInStr 1 (strlen allVluesInStr - 1) in
        let domainDef=sprintf "definition %s::\"nat set\" where [simp]: \"%s \\<equiv> {%s}\"\n" (typeName, typeName,Str) in
	enumValDefStr^domainDef;
	
letrec statementPartlyEnableForm1 typeTable env S (neg (eqn l r))=
    statementPartlyEnableForm  typeTable	env S (neg (eqn l r) )
    
/\ statementPartlyEnableForm1  typeTable env S (neg f)=
   val (andList flist) =f in
   statementPartlyDisableForm 	 typeTable env S (hd flist) =NONE =>
   length (tl flist)=1 => statementPartlyDisableForm  typeTable	env S (el 1 (tl flist))
   |statementPartlyEnableForm1  typeTable env S (neg (andList (tl flist)))
   |statementPartlyDisableForm 	 typeTable env S (hd flist)
   
/\statementPartlyEnableForm1  typeTable env S f=statementPartlyEnableForm  typeTable env S f;
   
   
   
let iniValidateInv  typeTable S Inv resultTab=
  val (implyForm ant0 cons0)=Inv in
  let env=SOME (tbl_create 1) then
  let env=statementPartlyEnableForm1  typeTable env S cons0 then
      env=NONE => 
      let env=SOME (tbl_create 1) then
      let env=statementPartlyDisableForm  typeTable env S ant0 then
         env=NONE =>error "ini predicate cannot satisfy the predicate\n"  
         | tbl_member resultTab Inv => resultTab | tbl_insert resultTab Inv (Disable, env)   
      |tbl_member resultTab Inv => resultTab |tbl_insert resultTab Inv (Enable, env) ;
      
letrec iniValidateInvs  typeTable enumValTab S [] resultTab=resultTab
/\  iniValidateInvs  typeTable enumValTab S (Inv0:Invs)   resultTab = 
 print (formula2str  enumValTab Inv0) fseq 
 print "\n" fseq
  let resultTab1=iniValidateInv  typeTable S Inv0 resultTab then
    iniValidateInvs   typeTable enumValTab S (Invs)   resultTab1;
  
  
