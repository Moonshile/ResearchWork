<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Trans2smv</title>
  <meta name="generator" content="Haroopad 0.12.2" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF) repeat scroll 0 0 transparent;background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:medium none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:medium none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:medium none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:none no-repeat scroll 5px -27px #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:none repeat scroll 0 0 #FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:none repeat scroll 0 0 #EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:none repeat scroll 0 0 #75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:#1A3C6C solid 1px;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-bottom-width:0;border-left-width:0;border-right-width:0;border-top-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-width:none;min-height:0;outline-color:#112644;outline-style:none;outline-width:0;overflow-x:visible;overflow-y:visible;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;border:0 none;color:#ccc;height:3px;padding:0}hr.underscore{border:0 none!important;height:30px;padding:0;-webkit-margin-before:0;-webkit-margin-after:0}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:#fff url(../img/ajax.gif) no-repeat center center}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}.markdown{padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-break:break-all;word-wrap:break-word}.markdown pre{border-radius:3px;word-break:break-all;word-wrap:break-word;overflow:auto}.markdown pre code{display:block}.markdown pre>code{border:1px solid #ccc;white-space:pre;padding:.5em;margin:0}.markdown code{border-radius:3px;word-break:break-all;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown table{padding:0;border-collapse:collapse;border-spacing:0}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}.markdown em.underline{font-style:normal;text-decoration:underline}.markdown strong.highlight{color:#000;padding:0 5px;background-color:#fdffb6;-webkit-box-shadow:#fdffb6 0 0 5px;-moz-box-shadow:#fdffb6 0 0 5px;box-shadow:#fdffb6 0 0 5px}.github{padding:20px;color:#000;font-size:15px;font-family:"Lucida Grande","Lucida Sans Unicode","Lucida Sans",AppleSDGothicNeo-Medium,'Segoe UI','Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;-webkit-font-smoothing:antialiased}.github a{color:#3269a0}.github a:hover{color:#4183c4}.github h2{border-bottom:1px solid #e6e6e6;line-height:1.7em}.github h6{color:#777}.github hr{border:1px solid #e6e6e6}.github pre>code{font-size:.9em;font-family:Consolas,Inconsolata,Courier,monospace}.github blockquote{border-left:4px solid #e6e6e6;padding:0 15px;font-style:italic}.github table{background-color:#fafafa}.github table tr td,.github table tr th{border:1px solid #e6e6e6}.github table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.hljs-template_comment,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.clojure .hljs-title,.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}
  body{width:80%; margin-left:10% !important;}
  </style>
</head>
<body class="markdown github">
<ul>
<li><span class="title">
<a href="#translate-forte-to-smv" title="Translate Forte to SMV">Translate Forte to SMV</a>
</span>
<!--span class="number">
0
</span-->
<ul>
<li><span class="title">
<a href="#basics-about-forte-model" title="Basics about Forte Model">Basics about Forte Model</a>
</span>
<!--span class="number">
1
</span-->
</li>
<li><span class="title">
<a href="#basics-about-smv-model" title="Basics about SMV Model">Basics about SMV Model</a>
</span>
<!--span class="number">
2
</span-->
</li>
<li><span class="title">
<a href="#strategy-to-translation" title="Strategy to Translation">Strategy to Translation</a>
</span>
<!--span class="number">
3
</span-->
<ul>
<li><span class="title">
<a href="#instantiate-rules" title="Instantiate Rules">Instantiate Rules</a>
</span>
<!--span class="number">
4
</span-->
</li>
<li><span class="title">
<a href="#instantiate-invariants" title="Instantiate Invariants">Instantiate Invariants</a>
</span>
<!--span class="number">
5
</span-->
</li>
<li><span class="title">
<a href="#instantiate-variables" title="Instantiate Variables">Instantiate Variables</a>
</span>
<!--span class="number">
6
</span-->
</li>
<li><span class="title">
<a href="#analysis" title="Analysis">Analysis</a>
</span>
<!--span class="number">
7
</span-->
</li>
<li><span class="title">
<a href="#translation" title="Translation">Translation</a>
</span>
<!--span class="number">
8
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#some-tips" title="Some Tips">Some Tips</a>
</span>
<!--span class="number">
9
</span-->
<ul>
<li><span class="title">
<a href="#about-`#if`" title="About #if">About #if</a>
</span>
<!--span class="number">
10
</span-->
</li>
<li><span class="title">
<a href="#about-select-rules-randomly" title="About Select Rules Randomly">About Select Rules Randomly</a>
</span>
<!--span class="number">
11
</span-->
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><hr class="section"><h2 id="translate-forte-to-smv"><a name="translate-forte-to-smv" href="#translate-forte-to-smv"></a>Translate Forte to SMV</h2><p>Cache coherence protocols could be translated to a <em>guarded statements</em> format, on which our <em>Forte</em> semantics model is based. And if we have a Forte model of a cache coherence protocol, it should be easy to be translated to other formats such as <em>SMV</em> in the corresponding syntactic level.</p><h3 id="basics-about-forte-model"><a name="basics-about-forte-model" href="#basics-about-forte-model"></a>Basics about Forte Model</h3><p>Our Forte model is based on the following definitions.</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;lettype varType =
    Global {name::string} |
    Param {name::string} {id::int};

lettype expType =
    Var varType |
    Const int |
    iteForm formula expType expType |
    fun string (expType list)
andlettype formula =
    pred (expType list) |
    eqn {left::expType} {right::expType} |
    neg {form::formula} |
    andList {glist::formula list}  |
    orList  {glist::formula list} |
    implyForm {ant::formula} {cons::formula} |
    forallForm {N::int} {fnForm::int-&amp;gt;formula} |
    chaos |
    miracle;

lettype statement =
    assign varType expType |
    parallel (statement list) |
    forallStatement {N::int} {fnForm::int-&amp;gt;statement};

lettype rule = guard formula statement;
&lt;/code&gt;&lt;/pre&gt;">lettype varType =
    Global {name::string} |
    Param {name::string} {id::int};

lettype expType =
    Var varType |
    Const int |
    iteForm formula expType expType |
    fun string (expType list)
andlettype formula =
    pred (expType list) |
    eqn {left::expType} {right::expType} |
    neg {form::formula} |
    andList {glist::formula list}  |
    orList  {glist::formula list} |
    implyForm {ant::formula} {cons::formula} |
    forallForm {N::int} {fnForm::int-&gt;formula} |
    chaos |
    miracle;

lettype statement =
    assign varType expType |
    parallel (statement list) |
    forallStatement {N::int} {fnForm::int-&gt;statement};

lettype rule = guard formula statement;
</code></pre><ul>
<li>varType: represents variables in a cache coherence protocol, which might be either global or a parameterized one. The parameterized variables is similar to arrays in other languages.</li>
<li>expType: represents expressions including only variables and constants. Complex expressions are not supported yet. Besides, <em>iteForm</em>, which is designed for <em>selection expression</em>, is also supported, however, not suggested. So is <em>fun</em> type.</li>
<li>formula: represents boolean expressions.<ul>
<li>eqn: represents <em>equation</em> expression.</li>
<li>chaos: represents <em>TRUE</em>.</li>
<li>miracle: represents <em>FALSE</em>.</li>
<li>neg: represents <em>negation</em> expression.</li>
<li>andList: represents <em>logical and</em> expression.</li>
<li>orList: represents <em>logical or</em> expression.</li>
<li>implyForm: represents <em>implication</em> expression.</li>
<li>forallForm: represents <em>for all</em> expression. It is equivalent to a <em>andList</em> expression, because in <em>forallForm</em>, the <em>fnForm</em> is a mapper maps an integer in range 1 to N to a formula, and relation to all these formulae is <em>and</em>.</li>
</ul>
</li>
<li>statement: represents a set of assignments.<ul>
<li>assign: represents an assignment which assigns the <em>expType</em> to the <em>varType</em>.</li>
<li>parallel: represents a set of parallel assignments.</li>
<li>forallStatement: similar to <em>for</em> clause in other languages, but is parallel.</li>
</ul>
</li>
<li>rule: represents a transition rule which has a <em>guarded statements</em> form.</li>
</ul><h3 id="basics-about-smv-model"><a name="basics-about-smv-model" href="#basics-about-smv-model"></a>Basics about SMV Model</h3><p>An SMV Model is organized in a <em>main MODULE</em>, which consists of three part: <em>VAR</em>, <em>ASSIGN</em>, <em>SPEC</em>. That is</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;MODULE main
VAR
    -- variable definitions --
ASSIGN
    -- initializations and transitions --
SPEC
    -- property specifications --
SPEC
    -- there might be more SPECs --
&lt;/code&gt;&lt;/pre&gt;">MODULE main
VAR
    -- variable definitions --
ASSIGN
    -- initializations and transitions --
SPEC
    -- property specifications --
SPEC
    -- there might be more SPECs --
</code></pre><ul>
<li><p>VAR: all variables are defined in here, support <em>boolean</em> (<code>TRUE</code>/<code>FALSE</code>), <em>integer range</em> (<code>1 .. 2</code> or <code>-2 .. -1</code>), <em>enumeration</em> (<code>{red, black, blue}</code>, NOTE that must in lowwer case) and so on. Variable names could include <code>.</code> and <code>[]</code> such as <code>a.b.c[0]</code>. and a full definition of some variables are as:</p>
<pre><code data-origin="&lt;pre&gt;&lt;code&gt;  VAR
      a.b.c[0] : 1..2;
      a.b.c[1] : 1..2;
      a.d : {yes, no, unknown};
      a.e : boolean;
&lt;/code&gt;&lt;/pre&gt;">  VAR
      a.b.c[0] : 1..2;
      a.b.c[1] : 1..2;
      a.d : {yes, no, unknown};
      a.e : boolean;
</code></pre></li>
<li><p>ASSIGN: include initializations <code>init</code> and transitions <code>next</code>. The initializations are executed the moment the code is ran. All transitions will be execution <strong>parallel</strong> to enter next state, and check all properties, then continue their next round execution.</p>
<pre><code data-origin="&lt;pre&gt;&lt;code&gt;  ASSIGN
      init(a.e) := FALSE;
      next(a.e) := TRUE;
      next(a.b.c[0]) :=
          case
              a.e : 1;
              TRUE: 2;
          esac;
&lt;/code&gt;&lt;/pre&gt;">  ASSIGN
      init(a.e) := FALSE;
      next(a.e) := TRUE;
      next(a.b.c[0]) :=
          case
              a.e : 1;
              TRUE: 2;
          esac;
</code></pre></li>
<li><p>SPEC: represents property which this SMV code must hold. It is written in <em>CTL</em> formula.</p>
<pre><code data-origin="&lt;pre&gt;&lt;code&gt;  SPEC
      AF (a.b.c[0] = 1)
&lt;/code&gt;&lt;/pre&gt;">  SPEC
      AF (a.b.c[0] = 1)
</code></pre></li>
</ul><h3 id="strategy-to-translation"><a name="strategy-to-translation" href="#strategy-to-translation"></a>Strategy to Translation</h3><p>As we know, in Forte, all rules, invariants, even variables, could be parameterized. However, SMV is a simple but complete language. So this translation work is not trivial. Obviously, the very first step is to instantiate all parameterized rules, invariants and variables. Then, we need to analyze these elements to extract information needed. Finally, we act the translation.</p><h4 id="instantiate-rules"><a name="instantiate-rules" href="#instantiate-rules"></a>Instantiate Rules</h4><p>Parameterized rules are functions in fact, which map the parameters to the corresponding rules. The type of rules is as <code>int -&gt; *a -&gt; *b -&gt; *c -&gt; *d -&gt; rule</code>. In this example, the latter four parameters do not have type <code>int</code>, because this is a rule with one parameter.</p><p>To instantiate a rule, we need its parameter information including parameters’ count and type. However, even we know these information, it is also difficult to instantiate the rules automatically, because different rules with different count of parameters are of different types, e.g., <code>int -&gt; *a -&gt; *b -&gt; *c -&gt; *d -&gt; rule</code> and <code>int -&gt; *a -&gt; *b -&gt; rule</code> are different types. And once our instantiation function were evaluated to a specific rule type, it could not be called with other types!</p><p>In fact, if you think in another way, it will be much more easier to instantiate rules. A Forte program about a cache coherence protocol is written by a user who knows how many parameters there is. So when the user need to translate his code, he should provide the way to instantiate rules, e.i., provide a function maps a parameterized rule and its actual parameter list to a actual rule. For example, to instantiate a 5-parameter rule, provide</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;let ruleFuncMap rule [a, b, c, d, e] = rule a b c d e;
&lt;/code&gt;&lt;/pre&gt;">let ruleFuncMap rule [a, b, c, d, e] = rule a b c d e;
</code></pre><p>To generate the actual parameter lists for each parameterized rule, the user should also provide a rule-parameter-type table. For example, suppose there is a rule named <code>Test</code> whose type is <code>int -&gt; *a -&gt; *b -&gt; *c -&gt; *d -&gt; rule</code>:</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;let NodeType = [1, 2]; // there are two nodes

// the rule-parameter-type table
let paraTypeTable =
    let t = tbl_create 1 in
    // [] represents parameter type of useless parameters
    let t = tbl_insert t &quot;Test&quot; [[NodeType], [], [], [], []] in
    t;
&lt;/code&gt;&lt;/pre&gt;">let NodeType = [1, 2]; // there are two nodes

// the rule-parameter-type table
let paraTypeTable =
    let t = tbl_create 1 in
    // [] represents parameter type of useless parameters
    let t = tbl_insert t "Test" [[NodeType], [], [], [], []] in
    t;
</code></pre><p>Then what we need is that generate actual parameter lists with the parameter types. For example, provide <code>[[1, 2], [], [], [], []]</code>, we produce <code>[1, 0, 0, 0, 0]</code> and <code>[2, 0, 0, 0, 0]</code>, which is what we want. This is not a difficult work.</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;// generate all possible combinations for a specific choice list
// for example, input [[1,2],[1,2],[]] gives [[1,1,0],[1,2,0],[2,1,0],[2,2,0]]
// NOTE that [] will be generated as 0
letrec combinationGen res [] =
        res
    /\ combinationGen res ([]:choice) =
        combinationGen (map (\x. x@[0]) res) choice
    /\ combinationGen [] ([]:choice) =
        combinationGen [[0]] choice
    /\ combinationGen [] (p:choice) =
        combinationGen (map (\x. [x]) p) choice
    /\ combinationGen res (p:choice) =
        let incPara res i = map (\x. x@[i]) res in
        combinationGen (itlist (\x.\r. (incPara res x)@r) p []) choice;
// combinationGen
&lt;/code&gt;&lt;/pre&gt;">// generate all possible combinations for a specific choice list
// for example, input [[1,2],[1,2],[]] gives [[1,1,0],[1,2,0],[2,1,0],[2,2,0]]
// NOTE that [] will be generated as 0
letrec combinationGen res [] =
        res
    /\ combinationGen [] ([]:choice) =
        combinationGen [[0]] choice
    /\ combinationGen res ([]:choice) =
        combinationGen (map (\x. x@[0]) res) choice
    /\ combinationGen [] (p:choice) =
        combinationGen (map (\x. [x]) p) choice
    /\ combinationGen res (p:choice) =
        let incPara res i = map (\x. x@[i]) res in
        combinationGen (itlist (\x.\r. (incPara res x)@r) p []) choice;
// combinationGen
</code></pre><h4 id="instantiate-invariants"><a name="instantiate-invariants" href="#instantiate-invariants"></a>Instantiate Invariants</h4><p>Instantiation of invariants is quite similar to the process for rules, even we can use a same map function. However, you must write the map function with another name again, because after evaluation, the function for rules will have type <code>rule</code>, and here it should have type <code>formula</code>.</p><h4 id="instantiate-variables"><a name="instantiate-variables" href="#instantiate-variables"></a>Instantiate Variables</h4><p>It’s an easy work. For a parameterized variable <code>Param "v" i</code>, just translate to <code>v[i]</code>.</p><h4 id="analysis"><a name="analysis" href="#analysis"></a>Analysis</h4><p>The goal of analysis is to generate an intermediate result, so that we can act the translation easily.</p><p>As we known, the rules have type <code>guard formula statement</code>, and all statements have type or equivalent type <code>parallel ((assign varType expType) list)</code>. Our analysis work for rules is to extract informations about each variable. The information contains the variables is modified in which rule, and what value the variable is to be assigned. These informations are stored in a table, with the name of variables as key, and corresponding tupls <code>(associatedGuardFormulae, associatedExpressions)</code> as value. Once this work was done, the actual variables is also ready.</p><p>The analysis for initialization is quite similar but a little different, which has the sequence of <code>expType</code> assigned as value.</p><h4 id="translation"><a name="translation" href="#translation"></a>Translation</h4><p>The translation is not very difficult. And finally we get a entrance function:</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;// do translation
let trans2smv fileName typeTab ruleTab paraTypeTab invTab invTypeTab init ruleFuncMap invFuncMap enumValTab dist =
    let file = fopen (fileName^&quot;.smv&quot;) &quot;w&quot; in
    fputs file &quot;\n-- This program is generated by trans2smv from its forte version. --\n&quot; fseq
    fputs file &quot;\nMODULE main\n&quot; fseq
    fputs file &quot;\nVAR\n&quot; fseq
    fputs file (transVar 1 typeTab ruleTab paraTypeTab ruleFuncMap enumValTab dist) fseq
    fputs file &quot;\nASSIGN\n&quot; fseq
    fputs file (transInit 1 init enumValTab dist) fseq
    fputs file (transNext 1 ruleTab paraTypeTab ruleFuncMap enumValTab dist) fseq
    fputs file (transInv 0 invTab invTypeTab invFuncMap enumValTab dist) fseq
    fclose file;
// trans2smv
&lt;/code&gt;&lt;/pre&gt;">// do translation
let trans2smv fileName typeTab ruleTab paraTypeTab invTab invTypeTab init ruleFuncMap invFuncMap enumValTab dist =
    let file = fopen (fileName^".smv") "w" in
    fputs file "\n-- This program is generated by trans2smv from its forte version. --\n" fseq
    fputs file "\nMODULE main\n" fseq
    fputs file "\nVAR\n" fseq
    fputs file (transVar 1 typeTab ruleTab paraTypeTab ruleFuncMap enumValTab dist) fseq
    fputs file "\nASSIGN\n" fseq
    fputs file (transInit 1 init enumValTab dist) fseq
    fputs file (transNext 1 ruleTab paraTypeTab ruleFuncMap enumValTab dist) fseq
    fputs file (transInv 0 invTab invTypeTab invFuncMap enumValTab dist) fseq
    fclose file;
// trans2smv
</code></pre><h3 id="some-tips"><a name="some-tips" href="#some-tips"></a>Some Tips</h3><h4 id="about-`#if`"><a name="about-`#if`" href="#about-`#if`"></a>About <code>#if</code></h4><p>Use <code>#if</code> to ensure that every module of Forte could be loaded only once. The following example is to load <code>createIsaModel0125.fl</code>, but if it was already loaded, we would do nothing.</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;#if (is_defined &quot;findInvsFromParaRulesByInvs&quot;);
    let createIsaModel = ();
#else;
    let createIsaModel = load &quot;creatIsaModel0125.fl&quot;;
#endif;
createIsaModel;
&lt;/code&gt;&lt;/pre&gt;">#if (is_defined "findInvsFromParaRulesByInvs");
    let createIsaModel = ();
#else;
    let createIsaModel = load "creatIsaModel0125.fl";
#endif;
createIsaModel;
</code></pre><p>In fact, if we write the loaded files carefully, we need not do this everywhere we load it. For example, in trans2smv, we use</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;#if (NOT (is_defined &quot;trans2smv&quot;));
// code of trans2smv
#endif;
&lt;/code&gt;&lt;/pre&gt;">#if (NOT (is_defined "trans2smv"));
// code of trans2smv
#endif;
</code></pre><p>Then we can load trans2smv without do anything, because it would be loaded only once.</p><h4 id="about-select-rules-randomly"><a name="about-select-rules-randomly" href="#about-select-rules-randomly"></a>About Select Rules Randomly</h4><p>In Forte, if there are several rules could be executed, a random one will be selected. Unfortunately, after translate to SMV, all the rules whose guards are satisfied will be executed together. This is wrong! So we should simulate the selection in SMV.</p><p>After instantiation of rules, we know how many rules here is, then we numbered them, and add a guard condition in the <em>guard</em> part of each rule which requires the current chosen rule is itself so that transition of variables in SMV will be triggered only when the corresponding guard is satisfied and the rule is selected.</p><p>In SMV, the selection is simulated by a variable, and we need also define it, initialize it and modify it.</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
